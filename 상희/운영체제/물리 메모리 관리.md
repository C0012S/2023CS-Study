# 💡 물리 메모리 관리

# ✅ 메모리 관리의 개요
## 메모리 관리의 복잡성
메모리 구조는 1B 크기로 나뉜다.  
1B로 나뉜 각 영역은 메모리 주소로 구분하며 보통 0 번지부터 시작한다.  
CPU는 메모리에 있는 내용을 가져오거나 작업 결과를 메모리에 저장하기 위해 메모리 주소 레지스터(MAR)를 사용한다.

<br/>

폰노이만 구조의 컴퓨터에서 메모리는 유일한 작업 공간이며 모든 프로그램은 메모리에 올라와야 실행이 가능하다.  
일괄 처리 시스템에서는 한 번에 한 가지 작업만 처리했기 때문에 메모리 관리가 어렵지 않았다.  
시분할 시스템에서는 운영체제를 포함한 모든 응용 프로그램이 메모리에 올라와 실행되기 때문에 메모리 관리가 복잡하다.

<br/>

운영체제도 프로그램이므로 메모리에 올라와야 실행할 수 있다.  
메모리에는 사용자 프로세스뿐만 아니라 운영체제 프로세스도 공존한다.  
컴퓨터의 전원 버튼을 누르면 부팅이 이루어진다. 이때 하드디스크에 저장된 운영체제가 메모리에 올라간다.

<br/>

메모리 관리는 운영체제를 비롯해 여러 작업을 동시에 처리할 때 메모리를 어떻게 관리하는가에 관한 문제이다.  
복잡한 메모리 관리는 메모리 관리 시스템(Memory Management System, MMS)이 담당한다.

<br/>

## 메모리 관리의 이중성
메모리 관리의 이중성이란 프로세스 입장에서는 메모리를 독차지하려 하고, 메모리 관리자 입장에서는 되도록 관리를 효율적으로 하고 싶어 하는 것을 말한다.

<br/>

프로세스가 작업하는 도중에 할당된 공간이 부족하면 메모리 관리자는 새로운 공간을 확보하기 위해 옆의 프로세스를 밀어내거나 더 큰 공간으로 해당 프로세스를 옮겨 준다.  
작업을 마치고 난 후 빈 공간이 생기면 다음 작업을 위해 빈 공간을 어떻게 처리할지도 결정한다.  
빈 공간이 여러 개 생기면 합쳐서 하나의 큰 공간을 만드는데, 이렇게 하기 위해 현재 작업 중인 공간을 옆으로 밀고 작은 공간을 합쳐나간다.  
이렇게 매번 작업 공간을 키웠다 줄였다 하는 것은 매우 복잡한 일이다.

<br/>

메모리 관리의 이중성은 프로세스 입장에서 작업의 편리함과 관리자 입장에서 관리의 편리함이 충돌을 일으키는 것을 말한다.  
현대의 메모리 관리 시스템은 프로세스와 메모리 관리자의 상충되는 요구 사항을 완벽하게 처리한다.

<br/>

## 소스 코드의 번역과 실행
### 컴파일러와 인터프린터의 동작
컴퓨터에서 작동하는 응용 프로그램은 프로그래밍 언어로 만들며 보통은 컴파일러를 사용하여 작성한 프로그램을 실행 가능한 코드로 변경한다.  
프로그램을 만들 때 0과 1의 기계어로 만들면 처음부터 컴퓨터에서 바로 실행 가능한 코드로 만들 수 있다.  
하지만 기계어는 배우기 어렵고 이해하기 힘들다. 기계어와 가장 유사한 언어인 어셈블리어도 마찬가지이다.

<br/>

기계어와 어셈블리어는 컴퓨터의 동작을 가장 직접적으로 표현한 언어로 저급 언어(Low Level Language)라고 한다.  
저급 언어와 반대되는 개념인 고급 언어(High Level Language)는 사용자가 이해하기 쉽게 프로그래밍할 수 있는 언어로 C 언어와 자바가 대표적인 예이다.

<br/>

언어 번역 프로그램은 고급 언어로 작성한 소스 코드를 컴퓨터가 실행할 수 있는 기계어로 번역하는 프로그램이다.  
대표적인 언어 번역 프로그램은 컴파일러(Compiler)와 인터프리터(Interpretor)이다.  
- 컴파일러
    - 소스 코드를 컴퓨터가 실행할 수 있는 기계어로 번역한 후 한꺼번에 실행한다.
    - C 언어, 자바 등이 이 방식으로 프로그램을 실행한다.
- 인터프리터
    - 소스 코드를 한 행씩 번역하여 실행한다.
    - 자바스크립트, 베이직 등이 이 방식으로 프로그램을 실행한다.

<br/>

### 컴파일러의 목적
- 오류 발견
    - 컴파일러의 첫 번째 목적은 소스 코드에서 오류를 발견하여 실행 시 문제가 없도록 하는 것이다.
    - 컴파일러는 오류를 찾기 위해 심벌 테이블(Symbol Table)을 사용한다.
        - 심벌 테이블은 변수 선언부에 명시한 각 변수의 이름과 종류(Type)을 모아 놓은 테이블로, 선언하지 않은 변수를 사용하지는 않았는지, 변수에 다른 종류의 데이터를 저장하지 않았는지 알 수 있다.
- 코드 최적화
    - 컴파일러의 두 번째 목적은 최적화이다.
    - 군더더기와 사용하지 않는 변수를 삭제하면 더욱 간결해져서 실행 속도가 빨라진다.

<br/>

결론적으로 컴파일러는 실행하기 전에 코드를 점검하여 오류를 수정하고 최적화함으로써 작고 빠른 실행 파일을 만든다.

<br/>

### 컴파일러와 인터프리터의 차이
- 컴파일러를 사용하는 프로그래밍 언어는 변수를 먼저 선언한 후 코드를 작성한다.
    - 변수 선언은 오류를 찾고 코드를 최적화하기 위해 반드시 필요한 작업이다.
- 컴파일러는 실행 전에 소스 코드를 점검하여 오류를 수정하고 필요 없는 부분을 정리하여 최적화된 실행 파일을 만든다.
- 인터프리터는 한 줄씩 위에서부터 아래로 실행되기 때문에 같은 일을 반복하는 경우나 필요 없는 변수를 확인할 수 없다.
- 따라서 크고 복잡한 프로그램에는 컴파일러를 사용하고 간단한 프로그램에는 인터프리터를 사용한다.

<br/>

- 컴파일러를 사용하는 자바와 인터프리터를 사용하는 자바스크립트 비교

| 구분 | 자바 | 자바스크립트 |
| --- | --- | --- |
| 변수 | 변수를 선언해야 한다. | 변수를 선언할 필요가 없다. |
| 실행 | 컴파일 후 실행된다. | 한 줄씩 실행된다. |
| 장점 | 오류 찾기와 코드 최적화, 분할 컴파일에 의한 공동 작업이 가능하다. | 실행이 편리하다. |
| 사용 프로그램 | 대형 프로그램 | 간단한 프로그램 |

<br/>

### 컴파일 과정
컴파일은 사용자가 작성한 소스 코드를 목적 코드(Object Code)로 변환한 후 라이브러리를 연결하고 최종 실행 파일을 만들어 실행하는 과정이다.

<br/>

1. 소스 코드 작성 및 컴파일
    - 소스 코드를 작성하여 컴파일하면 목적 코드가 만들어진다.
    - 컴퓨터는 0과 1의 기계어만 인식할 수 있기 때문에 사용자가 작성한 소스 코드를 컴파일러로 일차로 번역한다.
        - 이렇게 해서 얻은 코드가 목적 코드이다.
2. 목적 코드와 라이브러리 연결
    - 목적 코드가 만들어지면 라이브러리에 있는 코드를 목적 코드에 삽입하여 최종 실행 파일을 만든다.
        - 라이브러리
            - 자주 사용하는 함수를 시스템 내에 미리 만들어 둔 것이다.
            - 프로그래머가 직접 만들기 어렵거나 만드는 데 시간이 많이 걸리는 함수를 파일 형태로 모아 놓은 것이다.
3. 동적 라이브러리를 포함하여 최종 실행
    - 동적 라이브러리(Dynamic Library)
        - 실행할 때 삽입되는 함수를 가진 라이브러리이다.
    - 동적 라이브러리 방식에서는 함수가 변경되어도 새로 컴파일할 필요가 없다. 함수가 변경되었을 때는 새로운 라이브러리만 사용하여 실행하면 된다.
        - 과거에는 나중에 오류가 발견되거나 새로운 기능이 추가될 때마다 새로운 라이브러리를 가져와 다시 컴파일해야 했다.
    - 윈도우에서는 동적 라이브러리 파일을 DLL(Dynamic Link Loader)이라고 부른다. 윈도우에서 함수의 변경이 일어난 경우, 해당 DLL 파일을 구하여 특정 폴더에 삽입하면 새로운 기능을 사용할 수 있다.

<br/>

## 메모리 관리자의 역할
메모리 관리는 메모리 관리자가 담당한다.  
메모리 관리자는 메모리 관리 유닛(Memory Manage Unit, MMU)이라는 하드웨어인데 일반적으로 메모리 관리자라고 일컫는다.  
메모리 관리자의 작업은 가져오기(Fetch), 배치(Placement), 재배치(Replacement)이다.

<br/>

### 가져오기 작업
- 프로세스와 데이터를 메모리로 가져오는 작업이다.
- 메모리 관리자는 사용자가 요청하면 프로세스와 데이터를 모두 메모리로 가져온다.
    - 어떤 상황에서는 데이터의 일부만 가져와 실행하기도 한다.
- 사용자의 요청이 없더라도 앞으로 필요할 것이라고 예상되는 데이터를 미리 가져오기도 한다.

<br/>

### 배치 작업
- 가져온 프로세스와 데이터를 메모리의 어떤 부분에 올려 놓을지 결정하는 작업이다.
- 배치 작업 전에 메모리를 어떤 크기로 자를 것인지가 매우 중요하다.
    - 같은 크기로 자르느냐, 실행되는 프로세스의 크기에 맞게 자르느냐에 따라 메모리 관리의 복잡성이 달라지기 때문이다.
- 나누어진 메모리의 구역에 따라 프로세스와 데이터를 어떤 위치에 놓을지 결정하는 것이 바로 배치 작업이다.

<br/>

### 재배치 작업
- 새로운 프로세스를 가져와야 하는데 메모리가 꽉 찼다면 메모리에 있는 프로세스를 하드디스크로 옮겨 놓아야 새로운 프로세스를 메모리에 가져올 수 있다.
- 꽉 차 있는 메모리에 새로운 프로세스를 가져오기 위해 오래된 프로세스를 내보내는 작업이 재배치 작업이다.

<br/>

메모리 관리자는 가져오기, 배치, 재배치 작업 시 다음과 같은 정책을 수립하여 그 정책에 따라 메모리를 관리한다. 

<br/>

### 가져오기 정책
- 프로세스가 필요로 하는 데이터를 언제 메모리로 가져올지 결정하는 정책이다.
- 프로세스가 요청할 때 메모리로 가져오는 것이 일방적인 방법이다.
- 필요하다고 예상되는 데이터를 미리 가져오는 방법(Prefetch)도 있다.

<br/>

### 배치 정책
- 가져온 프로세스를 메모리의 어떤 위치에 올려 놓을지 결정하는 정책이다.
- 메모리를 같은 크기로 자르는 것을 페이징(Paging)이라고 하며 프로세스의 크기에 맞게 자르는 것을 세그먼테이션(Segmentation)이라고 한다.
- 배치 정책은 페이징과 세그먼테이션의 장단점을 파악하여 메모리를 효율적으로 관리할 수 있도록 정책을 만드는 것이다.
    - 이는 한정된 메모리를 효율적으로 사용하기 위한 것이다.
    - 시스템의 효율을 좌우하는 매우 중요한 기준이다.

<br/>

### 재배치 정책
- 메모리가 꽉 찼을 때, 메모리 내에 있는 어떤 프로세스를 내보낼지 결정하는 정책이다.
- 앞으로 사용하지 않을 프로세스를 내보내면 시스템의 성능이 올라가지만, 자주 사용할 프로세스를 내보내면 성능이 떨어진다.
- 앞으로 사용하지 않을 프로세스를 찾아서 내보내는 알고리즘을 교체 알고리즘(Replacement Algorithm)이라고 한다.

<br/>
<br/>

# ✅ 메모리 주소
메모리에 접근할 때는 주소를 이용한다.  
메모리 주소는 절대 주소와 상대 주소로 나뉜다.

<br/>

## 32bit CPU와 64bit CPU의 차이
- CPU의 비트는 한 번에 다룰 수 있는 데이터의 최대 크기를 의미한다.
    - 32bit CPU는 한번에 다룰 수 있는 데이터의 최대 크기가 32bit이고, 64bit CPU는 64bit이다.
    - CPU 내부 부품은 모두 이 비트를 기준으로 제작된다.
    - 32bit CPU 내의 레지스터 크기는 전부 32bit이고, 산술 논리 연산장치도 32bit를 처리할 수 있도록 설계된다.
    - 데이터를 전송하는 각종 버스의 크기 즉, 대역폭도 32bit이다.
        - 32bit 대역폭의 버스를 통해 한 번에 옮겨지는 데이터의 크기는 당연히 32bit이다.
- CPU의 비트는 메모리 주소 공간(Address Space)의 크기와도 연관이 있다.
    - 32bit CPU의 경우 메모리 주소를 지정하는 레지스터인 메모리 주소 레지스터(MAR)의 크기가 32bit이므로 표현할 수 있는 메모리 주소의 범위가 0 ~ 2^32 - 1, 총 개수가 2^32 개이다.
        - 이를 16 진수로 나타내면 00000000 ~ FFFFFFFF이며 총 크기는 2^32B, 약 4GB이다.
        - 따라서 32bit CPU 컴퓨터는 메모리를 최대 4GB까지 사용할 수 있다.
    - 64bit CPU는 레지스터의 크기, 버스의 대역폭, 한 번에 처리되는 데이터의 최대 크기 등이 32bit CPU의 2 배이다.
        - 32bit CPU보다 처리 속도가 빠르고 사용할 수 있는 메모리도 크다.
        - 32bit CPU는 0 ~ 2^32 - 1 번지의 주소 공간을 제공하지만, 64bit CPU는 0 ~ 2^64 - 1 번지의 주소 공간을 제공한다.
        - 32bit CPU의 메모리는 4GB로 제한되지만, 64bit CPU의 메모리는 2^64B, 약 16,777,216TB이기 때문에 거의 무한대에 가까운 메모리를 사용할 수 있다.
        
        | 구분 | 32bit CPU | 64bit CPU |
        | --- | --- | --- |
        | 주소 범위 | 0 ~ 2^32 - 1 번지 | 0 ~ 2^64 - 1 번지 |
        | 총 크기 | 2^32B(약 4GB) | 2^64B(약 16,777,216TB) |
      
- 컴퓨터에는 메모리가 설치되며 각 메모리 주소 공간이 있다.
    - 이렇게 설치된 메모리의 주소 공간을 물리 주소 공간(Physical Address Space)이라고 한다.
    - 물리 주소 공간은 하드웨어 입장에서 바라본 주소 공간으로 컴퓨터마다 그 크기가 다르다.
    - 이와 반대로 사용자 입장에서 바라본 주소 공간은 논리 주소 공간(Logical Address Space)이라고 한다.

<br/>

## 절대 주소와 상대 주소
### 메모리 영역의 구분
아래 그림과 같은 단순 메모리 구조는 한 번에 한 가지 일만 처리하는 일괄 처리 시스템에서 볼 수 있다.

![Untitled](https://shacoding.com/wp-content/uploads/2022/06/image-12.png)

<br/>

메모리 관리자는 이러한 메모리를 운영체제 영역과 사용자 영역으로 나누어 관리한다.  
운영체제는 시스템을 관리하는 중요한 역할을 하기 때문에 사용자가 운영체제를 침범하지 못하도록 분리하여 관리한다.  
위의 그림에서는 운영체제가 0 ~ 359 번지를 사용하고, 사용자가 360 ~ 999 번지를 사용한다. 

<br/>

사용자 프로세스는 운영체제 영역을 피하여 메모리에 적재된다.  
단순 메모리 구조처럼 사용자 프로세스가 운영체제의 크기에 따라 매번 적재되는 주소가 달라지는 것은 번거로운 일이라 이를 개선하여 아래 그림과 같이 사용자의 프로세스를 메모리의 최상위부터 사용하는 방법이 있다.

![Untitled](https://shacoding.com/wp-content/uploads/2022/06/image-13.png)

<br/>

다시 말해 메모리를 최상위에서 운영체제 방향으로 내려오면서 사용하는 것이다.  
이 방법은 운영체제의 크기에 상관없이 사용자 영역의 시작점을 결정할 수 있으나 메모리를 거꾸로 사용하기 위해 주소를 변경하는 일이 복잡하기 때문에 잘 쓰이지 않는다.

<br/>

사용자 영역이 운영체제 영역으로 침범하는 것을 막으려면 하드웨어의 도움이 필요하다. 이는 CPU 내에 있는 경계 레지스터가 담당한다.  
경계 레지스터는 운영체제 영역과 사용자 영역 경계 지점의 주소를 가진 레지스터이다.  
메모리 관리자는 사용자가 작업을 요청할 때마다 경계 레지스터의 값을 벗어나는지 검사하고, 만약 경계 레지스터를 벗어나는 작업을 요청하는 프로세스가 있으면 그 프로세스를 종료한다.

<br/>

![Untitled](https://shacoding.com/wp-content/uploads/2022/06/image-14.png)

<br/>

### 절대 주소와 상대 주소의 개념
- 컴파일 방식을 사용하는 프로그램의 경우 컴파일 시 변수의 주소를 0 번지부터 배정한다.
- 컴파일 당시에는 변수가 메모리의 어느 위치에 올라가는지 알 수 없기 때문에 0 번지부터 배정하고 실제로 실행할 때 주소를 조정한다.
    - 만약 사용자 프로세스가 메모리의 400 번지에 올라간다면 프로세스 내 변수의 각 주소에 400을 더하는데, 이때 400 번지는 절대 주소(Absolute Address)이다.
- 절대 주소는 실제 물리 주소(Physical Address)를 가리키며 메모리 관리자 입장에서 바라본 주소이다.
    - 즉, 메모리 주소 레지스터가 사용하는 주소이다.
    - 컴퓨터에 꽂힌 램 메모리의 실제 주소를 말한다.
- 메모리 관리자는 절대 주소를 사용하지만, 사용자 입장에서 절대 주소는 불편하고 위험하다.
    - 절대 주소를 사용하면 매번 운영체제 영역을 확인해야 한다.
    - 현재 운영체제가 359 번지까지 사용하더라도 운영체제가 업그레이드되면 그 이상의 주소 범위를 사용할 수도 있다.
    - 운영체제 영역의 주소가 사용자에게 노출되면 실수나 고의적인 조작으로 운영체제 영역을 침범할 수도 있다.
- 사용자 프로세스 입장에서 운영체제 영역은 어차피 사용할 수 없는 공간이며 운영체제의 절대 주소(물리 주소)를 알 필요도 없다.
- 상대 주소(Relative Address)는 사용자 영역이 시작되는 번지를 0 번지로 변경하여 사용하는 주소 지정 방식이다.
    - 상대 주소는 사용자 프로세스 입장에서 바라본 주소이다.
    - 절대 주소와 관계없이 항상 0 번지부터 시작한다.
    - 상대 주소를 사용하면 프로세스 입장에서 상대 주소가 사용할 수 없는 영역의 위치를 알 필요가 없고, 주소가 항상 0 번지부터 시작하기 때문에 편리하다.

<br/>

![Untitled](https://shacoding.com/wp-content/uploads/2022/06/image-15.png)

<br/>

상대 주소는 사용자 프로세스 입장에서 운영체제가 어디서 끝나는지, 자신의 데이터가 어디에 존재하는지 알 필요 없이 주소 공간이 항상 0 번지부터 시작하는데, 이러한 주소 공간을 논리 주소 공간이라고 부른다.  
논리 주소 공간은 물리 주소 공간의 상대적인 개념이다.  
즉, 논리 주소 공간은 상대 주소를 사용하는 주소 공간이고, 물리 주소 공간은 절대 주소를 사용하는 주소 공간이다. 

<br/>

| 구분 | 절대 주소 | 상대 주소 |
| --- | --- | --- |
| 관점 | 메모리 관리자 입장 | 사용자 프로세스 입장 |
| 주소 시작 | 물리 주소 0 번지부터 시작 | 물리 주소와 관계없이 항상 0 번지부터 시작 |
| 주소 공간 | 물리 주소(실제 주소) 공간 | 논리 주소 공간 |

<br/>

### 상대 주소를 절대 주소로 변환하는 과정
메모리 접근 시 절대 주소를 사용하면 특별한 변환 과정 없이 작업을 할 수 있다.  
그러나 상대 주소를 사용하면 상대 주소를 실제 메모리 내의 물리 주소 즉, 절대 주소로 변환해야 한다.  
이러한 변환 작업은 프로세스가 실행되는 동안 메모리 관리자가 매우 빠르게 처리한다.

<br/>

![Untitled](https://shacoding.com/wp-content/uploads/2022/06/image-18.png)

<br/>

상대 주소를 절대 주소로 변환하는 과정은 위의 그림과 같다.
1. 사용자 프로세스가 상대 주소 40 번지에 있는 데이터를 요청한다.
2. CPU는 메모리 관리자에게 40 번지에 있는 내용을 가져오라고 명령한다.
3. 메모리 관리자는 재배치 레지스터를 사용하여 상대 주소 40 번지를 절대 주소 400 번지로 변환하고 메모리 400 번지에 저장된 데이터를 가져온다.

<br/>

메모리 관리자는 사용자 프로세스가 상대 주소를 사용하여 메모리에 접근할 때마다 상대 주소 값에 재배치 레지스터 값을 더하여 절대 주소를 구한다.  
재배치 레지스터는 주소 변환의 기본이 되는 주소 값을 가진 레지스터로, 메모리에서 사용자 영역의 시작 주소 값이 저장된다.  
사용자 프로세스 입장에서는 메모리 관리자가 재배치 레지스터를 사용하여 상대 주소를 절대 주소로 변환하기 때문에 메모리가 항상 0 번지부터 시작하는 연속된 작업 공간으로 보인다.

<br/>
<br/>

# ✅ 단일 프로그래밍 환경에서의 메모리 할당
## 메모리 오버레이
프로그램의 크기가 실제 메모리(물리 메모리)보다 클 때 전체 프로그램을 메모리에 가져오는 대신 적당한 크기로 잘라서 가져오는 기법을 메모리 오버레이(Memory Overlay)라고 한다.  
메모리 오버레이의 경우 프로그램을 몇 개의 모듈로 나누고 필요할 때마다 모듈을 메모리에 가져와 사용한다.  
전체 프로그램을 메모리에 올려 놓고 실행하기에는 메모리의 크기가 작기 때문에 실행하는 데 필요한 중요한 모듈만 올려 놓고 나머지는 필요할 때마다 메모리에 가져와 사용하는 것이다.

<br/>

아래 그림은 메모리 오버레이의 작동 방식을 보여 준다.  
프로그램 전체를 메모리에 올려 놓고 실행하는 것보다 속도가 느리지만, 메모리가 프로그램보다 작을 때도 실행할 수 있어 유용하다.

![Untitled](https://shacoding.com/wp-content/uploads/2022/06/image-19.png)

<br/>

메모리 오버레이에서 어떤 모듈을 가져오거나 내보낼지는 CPU 레지스터 중 하나인 프로그램 카운터(PC)가 결정한다.  
프로그램 카운터는 앞으로 실행할 명령어의 위치를 가리키는 레지스터로, 해당 모듈이 메모리에 없으면 메모리 관리자에게 요청하여 메모리로 가져오게 한다.

<br/>

### 메모리 오버레이의 의미
- 한정된 메모리에서 메모리보다 큰 프로그램의 실행이 가능하다.
    - 가상 메모리 시스템의 기본이 되는 개념이다.
- 프로그램 전체가 아니라 일부만 메모리에 올라와도 실행이 가능하다.
    - 프로그램은 개념적으로 한 덩어리이지만, 일부분만 가지고도 실행할 수 있다.
    - 메모리를 여러 조각으로 나누어 여러 프로세스에 할당할 수 있다는 의미이기도 하다.

<br/>

## 스왑
메모리 오버레이를 이용하면 메모리보다 큰 프로그램을 실행할 수 있다.

<br/>

메모리가 모자라서 쫓겨난 프로세스는 저장 장치의 특별한 공간에 모아 두는데 이러한 영역을 스왑 영역(Swap Area)이라고 부른다.  
스왑 영역에서 메모리로 데이터를 가져오는 작업은 스왑인(Swap In), 메모리에서 스왑 영역으로 데이터를 내보내는 작업은 스왑아웃(Swap Out)이라고 한다.  
스왑 영역은 메모리 관리자가 관리한다. 원래 하드디스크 같은 저장 장치는 저장 장치 관리자가 관리하지만, 스왑 영역은 메모리에서 쫓겨났다가 다시 돌아가는 데이터가 머무는 곳이기 때문에 저장 장치는 장소만 빌려 주고 메모리 관리자가 관리하는 것이다.  
메모리 오버레이에서는 메모리보다 큰 프로그램을 실행할 때 프로그램을 메모리보다 작은 크기의 모듈로 나누어서 사용한다. 여기에 스왑을 이용하면 스왑 영역의 크기가 메모리의 크기로 인식된다.  
다시 말해 사용자는 실제 메모리의 크기와 스왑 영역의 크기를 합쳐서 전체 메모리로 인식하고 사용할 수 있다.

<br/>
<br/>

# ✅ 다중 프로그래밍 환경에서의 메모리 할당
한 번에 여러 프로세스를 동시에 실행하는 경우 메모리 관리가 더욱 복잡해진다.  
프로세스들의 크기가 달라 메모리를 어떻게 나누어 사용할 것인지가 가장 큰 문제이다.

<br/>

## 메모리 분할 방식
메모리를 어떤 크기로 나눌 것인가는 메모리 배치 정책에 해당된다.  
메모리에 여러 개의 프로세스를 배치하는 방법은 크게 가변 분할 방식(Variable-Size Partitioning)과 고정 분할 방식(Fixed-Size Partitioning)으로 나뉜다.  
- 가변 분할 방식    
    : 프로세스의 크기에 따라 메모리를 나누는 것이다    
- 고정 분할 방식    
    : 프로세스의 크기와 상관없이 메모리를 같은 크기로 나누는 것이다.
    
<br/>

### 가변 분할 방식과 고정 분할 방식
가변 분할 방식은 관리가 복잡하나 고정 분할 방식은 관리가 용이하다.

<br/>

### 메모리 분할 방식의 구현
아래 그림은 가변 분할 방식과 고정 분할 방식이 메모리에서 어떻게 구현되는지를 보여 준다.

<br/>

![Untitled](https://shacoding.com/wp-content/uploads/2022/06/image-21.png)

<br/>

- 가변 분할 방식
    - 프로세스의 크기에 맞게 메모리가 분할되므로 메모리의 영역이 각각 다르다. (17 ~ 40KB)
    - 한 프로세스가 연속된 공간에 배치되기 때문에 연속 메모리 할당(Contiguous Memory Allocation)이라고 한다.
    - 가변 분할 방식의 장점
        - 가변 분할 방식에서는 프로세스를 한 덩어리로 처리하여 하나의 프로세스를 연속된 공간에 배치한다.
    - 가변 분할 방식의 단점
        - 가변 분할 방식은 메모리 관리가 복잡하다.
            - 메모리 통합 등의 부가적인 작업이 필요하므로 메모리 관리가 복잡하다.
- 고정 분할 방식
    - 프로세스의 크기에 상관없이 메모리가 같은 크기로 나뉘며 큰 프로세스가 메모리에 올라오면 여러 조각으로 나뉘어 배치된다.
    - 한 프로세스가 분산되어 배치되기 때문에 비연속 메모리 할당(Noncontiguous Memory Allocation)이라고 한다.
    - 고정 분할 방식의 장점
        - 메모리를 일정한 크기로 나누어 관리하기 때문에 메모리 관리가 수월하다.
            - 가변 분할 방식의 메모리 통합 같은 부가적인 작업을 할 필요가 없다.
    - 고정 분할 방식의 단점
        - 쓸모없는 공간으로 인해 메모리 낭비가 발생할 수 있다.
            - 즉, 일정하게 나누어진 공간보다 작은 프로세스가 올라올 경우 메모리 낭비가 발생한다.
                - 다른 프로세스가 사용할 수 없는 공간이라 메모리가 낭비되는 것이다.

<br/>

현대 운영체제에서 메모리 관리는 기본적으로 고정 분할 방식을 사용하면서 일부분은 가변 분할 방식을 혼합하고 있다.

<br/>

## 가변 분할 방식의 메모리 관리
가상 메모리 시스템에서는 가변 분할 방식을 세그먼테이션 기법이라고도 한다.

<br/>

### 프로세스 배치와 외부 단편화
가변 분할 방식은 빈 영역이 있어도 서로 떨어져 있으면 프로세스를 배정하지 못하는 것이 문제이다.  
이로 인해 작은 조각들이 발생하는 현상을 단편화(Fragmentation) 또는 조각화라고 한다.

<br/>

가변 분할 방식의 문제를 물리 메모리를 통해 살펴보면 아래 그림과 같다.

![Untitled](https://yansigit.github.io/posts/%eb%ac%bc%eb%a6%ac%eb%a9%94%eb%aa%a8%eb%a6%ac-%ea%b4%80%eb%a6%ac/Untitled%2010.png)

<br/>

- 물리 메모리에 프로세스 A, B, C, D, E를 순서대로 배치했을 때, 프로세스 B와 D가 종료되면 18KB와 17KB의 빈 공간이 생긴다.
- 이후 18KB보다 큰 프로세스가 들어오면 적당한 공간이 없어 메모리를 배정하지 못한다.
    - 가변 분할 방식에서 발생하는 이러한 작은 빈 공간을 외부 단편화(External Fragmentation)라고 한다.
    - 프로세스의 바깥쪽에 조각이 발생하기 때문에 이렇게 불리는 것이다.
- 가변 분할 방식에서는 외부 단편화로 인한 문제를 해결하기 위해 메모리 배치 방식(Memory Placement Strategy)이나 조각 모음(Defragmentation)을 사용한다.
    - 메모리 배치 방식은 작은 조각이 발생하지 않도록 프로세스를 배치하는 것이다.
    - 조각 모음은 조각이 발생했을 때, 작은 조각들을 모아서 하나의 큰 덩어리로 만드는 작업이다.
- 메모리 배치 방식은 가변 분할 방식에서 선처리에 해당하고 조각 모음은 후처리에 해당한다.

<br/>

### 메모리 배치 방식
가변 분할 방식의 외부 단편화 문제를 해결하기 위한 대표적인 메모리 배치 방식으로는 최초 배치(First Fit), 최적 배치(Best Fit), 최악 배치(Worst Fit)가 있다. 이 외에도 버디 시스템(Buddy System)이 있다.

<br/>

- 최초 배치
    - 최초 배치는 단편화를 고려하지 않는 것이다.
    - 프로세스를 메모리의 빈 공간에 배치할 때, 메모리에서 적재 가능한 공간을 순서대로 찾다가 첫 번째로 발견한 공간에 프로세스를 배치하는 방법이다.
- 최적 배치
    - 최적 배치는 메모리의 빈 공간을 모두 확인한 후, 적당한 크기 가운데 가장 작은 공간에 프로세스를 배치하는 방법이다.
- 최악 배치
    - 최적 배치와 정반대이다.
    - 최악 배치는 빈 공간을 모두 확인한 후, 가장 큰 공간에 프로세스를 배치하는 방법이다.

<br/>

![Untitled](https://yansigit.github.io/posts/%eb%ac%bc%eb%a6%ac%eb%a9%94%eb%aa%a8%eb%a6%ac-%ea%b4%80%eb%a6%ac/Untitled%2011.png)

<br/>

- 최초 배치 방식은 빈 공간을 찾아다닐 필요가 없다.
- 최적 배치 방식은 빈 공간을 모두 확인하는 부가적인 작업이 있지만, 딱 맞는 공간을 찾을 경우 단편화가 일어나지 않는다. 그러나 딱 맞는 공간이 없을 때는 아주 작은 조각을 만들어내는 단점이 있다.
    - 이러한 작은 공간은 버려질 가능성이 크다.
- 최악 배치 방식은 최적 배치와 반대로 접근한다.
    - 최적 배치 방식에서는 프로세스를 배치하고 남은 공간이 작아 쓸모없지만, 최악 배치 방식에서는 프로세스를 배치하고 남은 공간이 크기 때문에 쓸모가 있다.
        - 빈 공간의 크기가 클 때는 충분히 사용 가능한 크기이므로 효과적이지만, 빈 공간의 크기가 점점 줄어들면 최적 배치처럼 작은 조각을 만들어낸다.

<br/>

### 조각 모음
- 최초 배치, 최적 배치, 최악 배치 방식을 사용해도 단편화 현상이 발생한다.
- 원래 가변 분할 방식의 목적은 프로세스를 한덩어리로 취급하여 메모리 관리의 효율성을 높이는 것인데, 메모리 배치 방식으로는 근본적으로 문제를 해결하지 못한다.
- 가변 분할 방식에서는 메모리에 올라오는 프로세스가 차례대로 배치되기 때문에 공간 사용에 큰 문제가 없다.
- 그러나 작은 프로세스가 작업을 마치고 메모리에서 나가면 그 공간이 조각으로 남아 쓸모없어질 가능성이 크다.
    - 이렇게 단편화가 발생하면 이미 배치된 프로세스를 옆으로 옮겨 빈 공간들을 하나의 큰 덩어리로 만들어야 하는데 이것이 바로 **조각 모음**이다.

<br/>

- 조각 모음은 서로 떨어져 있는 여러 개의 빈 공간을 합치는 작업이다.
- 조각 모음은 다음과 같은 순서로 진행된다.
    1. 조각 모음을 하기 위해 이동할 프로세스의 동작을 멈춘다.
    2. 프로세스를 적당한 위치로 이동한다. 프로세스가 원래의 위치에서 이동하기 때문에 프로세스의 상대 주소 값을 바꾼다.
    3. 이러한 작업을 다 마친 후 프로세스를 다시 시작한다.
- 조각 모음을 하려면 프로세스를 중지시키고, 이동하고, 주소를 바꾸고, 다시 시작하는 작업을 해야 하기 때문에 많은 시간이 걸린다.
    - 이처럼 가변 분할 방식은 외부 단편화로 인해 조각 모음 같은 부가적인 작업이 필요하므로 메모리 관리가 복잡하다.

<br/>

## 고정 분할 방식의 메모리 관리
가상 메모리 시스템에서는 고정 분할 방식을 페이징이라고도 한다.  
가변 분할 방식과 달리 고정 분할 방식은 프로세스의 크기에 상관없이 메모리를 같은 크기로 나누기 때문에 관리하기가 편하다.  
그러나 프로세스가 메모리의 여러 조각에 나뉘어 저장되는 것이 문제이다.

<br/>

### 프로세스 배치와 내부 단편화
고정 분할 방식은 가변 분할 방식보다 공간을 효율적으로 관리한다.  
고정 분할 방식은 가변 분할 방식처럼 조각 모음을 할 필요가 없어 관리가 수월하므로 현대의 메모리 관리 시스템은 고정 분할 방식을 기본으로 사용하고 있다.

<br/>

### 내부 단편화
고정 분할 방식도 단점이 있다.  
일정하게 나뉜 메모리의 크기보다 작은 프로세스가 배치될 경우 낭비되는 공간이 생긴다는 것이다.  
즉, 고정 분할 방식에서는 일정한 크기로 나뉜 파티션 안쪽으로 작은 조각이 발생한다.  
이처럼 각 메모리 조각에 프로세스를 배치하고 공간이 남는 현상을 내부 단편화(Internal Fragmentation)라고 한다.  
같은 크기로 나뉜 공간의 내부에서 발생했기 때문에 이렇게 불리는 것이다.

<br/>

가변 분할 방식의 외부 단편화는 조각 모음으로 조정했으나 고정 분할 방식에서는 내부 단편화를 해결하기 위해 조각 모음을 할 수 없고 남는 공간을 다른 프로세스에 배정할 수도 없다.  
대신 동일하게 분할되는 공간의 크기를 조절하여 내부 단편화를 최소화한다.

<br/>

고정 분할 방식에서는 내부 단편화를 줄이기 위해 신중하게 메모리의 크기를 결정해서 나누어야 한다.  
그러나 사용하는 프로세스의 크기가 제각각이기 때문에 메모리를 얼마로 나누느냐에 관한 정답은 없다.

<br/>

가변 분할 방식과 고정 분할 방식을 비교하면 아래 표와 같다.  
메모리의 단위는 가상 메모리 시스템을 기준으로 한 것이다.

| 구분 | 가변 분할 방식 | 고정 분할 방식 |
| --- | --- | --- |
| 메모리 단위 | 세그먼테이션 | 페이징 |
| 특징 | 연속 메모리 할당 | 비연속 메모리 할당 |
| 장점 | 프로세스를 한 덩어리로 관리 가능 | 메모리 관리가 편리 |
| 단점 | 빈 공간의 관리가 어려움 | 프로세스가 분할되어 처리됨 |
| 단편화 | 외부 단편화 | 내부 단편화 |

<br/>

## 버디 시스템
가변 분할 방식의 단점인 외부 단편화를 완화하는 방법으로 버디 시스템이 있다.  
버디 시스템은 가변 분할 방식이지만, 고정 분할 방식과 유사한 점이 있다.

<br/>

### 버디 시스템의 작동 방식
버디 시스템의 특징은 가변 분할 방식과 고정 분할 방식의 중간 구조라는 것이다.

<br/>

버디 시스템의 작동 방식은 다음과 같다.  
1. 프로세스의 크기에 맞게 메모리를 1/2로 자르고, 프로세스를 메모리에 배치한다.
2. 나뉜 메모리의 각 구역에는 프로세스가 1 개만 들어간다.
3. 프로세스가 종료되면 주변의 빈 조각과 합쳐서 하나의 큰 덩어리를 만든다.

<br/>

### 버디 시스템의 특징
- 버디 시스템은 가변 분할 방식과 고정 분할 방식의 특징을 모두 가지고 있다.
    - 가변 분할 방식처럼 메모리가 프로세스 크기대로 나뉜다.
    - 고정 분할 방식처럼 하나의 구역에 다른 프로세스가 들어갈 수 없고, 메모리의 한 구역 내부에 조각이 생겨 내부 단편화가 발생한다.
- 버디 시스템이 가변 분할 방식보다 효과적으로 공간을 관리할 수 있는 이유는 비슷한 크기의 덩어리가 서로 모여 있어 통합하기 쉽기 때문이다.
    - 가변 분할 방식에서는 작은 조각이 큰 조각 사이사이에 있어 조각을 모으려면 큰 덩어리를 옮겨야 한다.
        - 그러나 버디 시스템에서는 비슷한 크기의 조각이 서로 모여 있기 때문에 작은 조각을 통합하여 큰 조각을 만들기가 쉽다.
    - 버디 시스템에서는 조각 모음을 하지 않아도 간단히 큰 덩어리를 만들 수 있다.
- 효율적인 공간 관리 측면에서 보면 고정 분할 방식과 버디 시스템은 비슷한 수준이다.
    - 그러나 공간을 1/2로 나누어가면서 메모리를 배분하는 버디 시스템보다 모든 공간을 똑같은 크기로 나누는 고정 분할 방식이 메모리 관리 측면에서 단순하기 때문에 버디 시스템보다 고정 분할 방식이 많이 사용되고 있다.

<br/>
<br/>

# 🗂 참고
- [책] 쉽게 배우는 운영체제
- [OS - 물리 메모리 관리 - SHA Computing (shacoding.com)](https://shacoding.com/2022/06/11/os-%EB%AC%BC%EB%A6%AC-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC/)
- [운영체제 - 물리 메모리 관리 (yansigit.github.io)](https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%AC%BC%EB%A6%AC-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC/)
