# 💡 멀티 스레딩

# ✅ 멀티 스레딩이란?

<br/>

![https://velog.velcdn.com/images/hkh1213/post/fa5ab1a8-0e06-4ccf-be2e-030f5d0ddc0b/image.png](https://velog.velcdn.com/images/hkh1213/post/fa5ab1a8-0e06-4ccf-be2e-030f5d0ddc0b/image.png)

<br/>

- 멀티 스레딩은 하나의 프로세스를 다수의 스레드로 구분하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시키는 것을 의미한다.    
    즉, 하나의 프로세스가 동시에 여러 개의 스레드를 수행할 수 있도록 해주는 것이다.    
- 하나의 프로그램에서 동시에 여러 개의 일을 수행할 수 있도록 해 준다.(사실 분산 처리를 통해 동시에 실행되는 것처럼 보이는 것이다.)    
    ex : 워드 프로세서에서 그림을 표시하고, 키 입력에 응답하며 철자 및 문법 검사를 계속 한다.
    
<br/>    

![https://velog.velcdn.com/images/hkh1213/post/2ee29388-3334-4a14-b54b-a3c9c5617ebf/image.png](https://velog.velcdn.com/images/hkh1213/post/2ee29388-3334-4a14-b54b-a3c9c5617ebf/image.png)

<br/>

하나의 프로세스에는 하나 이상의 스레드가 존재할 수 있다. 프로세스를 생성하는 비용보다 스레드를 생성하는 비용이 더 저렴하기 때문에 프로세스에 다수의 스레드를 생성하여 병렬 처리 하는 것이다.  
또한 프로세스는 데이터, 힙, 스택 영역을 서로 공유하지 않지만, 스레드는 스택 영역을 제외한 데이터, 힙 영역을 서로 공유하기 때문에 메모리 부분에서도 훨씬 효율적이다.

<br/>
<br/>

# ✅ 멀티 스레딩 장단점
## 멀티 스레딩 장점
- 응답성(Responsiveness)    
    : 프로그램의 일부분(스레드)이 중단되거나 긴 작업을 수행하더라도 프로그램의 수행이 계속되어 사용자에 대한 응답성이 증가한다.    
    ex : 멀티 스레드가 적용된 웹 브라우저 프로그램에서 하나의 스레드가 이미지 파일을 로드하고 있는 동안, 다른 스레드에서 사용자와 상호 작용 가능    
    싱글 스레드인 경우, 작업이 끝나기 전까지 사용자에게 응답하지 않는다. 반면 멀티스레드인 경우 작업을 분리해서 수행하므로 실시간으로 사용자에게 응답할 수 있다.    
- 자원 공유(Resource sharing)    
    : 프로세스는 오직 공유 메모리나 메시지 패싱을 이용해서 자원을 공유할 수 있지만, 스레드는 자신이 속한 프로세스 내의 스레드들과 메모리나 자원을 공유하여 효율적으로 사용할 수 있다.    
- 경제성(Economy)    
    : 프로세스 내 자원들과 메모리를 공유하기 때문에 메모리 공간과 시스템 자원 소모가 줄어든다. 스레드 간 통신이 필요한 경우에도 쉽게 데이터를 주고 받을 수 있으며, 프로세스의 Context Switching과 달리 스레드 간의 Context Switching은 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다.    
    프로세스를 새로 생성하는 비용보다 스레드를 새로 생성하는 게 훨씬 싸다.    
    실제로 Solaris에서 프로세스 생성은 스레드 생성보다 30배 느리고, switching은 5배 느리다.    
- 멀티 프로세서 활용    
    : 다중 CPU 구조에서는 각각의 스레드가 다른 프로세서에서 병렬로 수행될 수 있으므로 병렬성이 증가한다.    
- 확장성(Scalability)    
    : 싱글 스레드인 경우 한 프로세스는 오직 한 프로세서에서만 수행 가능하다. 반면 멀티 스레드인 경우 한 프로세스를 여러 프로세서에서 수행할 수 있으므로 훨씬 효율적이다.
    
<br/>    

## 멀티 스레딩 단점
- 임계 영역(Critical Section)은 둘 이상의 스레드가 동시에 실행하면 문제를 일으키는 코드 블록이다. 공유하는 자원에 동시에 접근하는 경우, 프로세스와는 달리 스레드는 데이터와 힙 영역을 공유하기 때문에 어떤 스레드가 다른 스레드에서 사용 중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다. 따라서 동기화가 필요하다.
- 동기화를 통해 스레드의 작업 처리 순서와 공유 자원에 대한 접근을 컨트롤할 수 있다.(Java에서 synchronized 키워드) 그러나 불필요한 부분까지 동기화를 하는 경우, 과도한 Lock으로 인해 병목 현상을 발생시켜 성능이 저하될 가능성이 높기 때문에 주의해야 한다. 동기화 방법에는 뮤텍스와 세마포어가 있다.
- Context Switching, 동기화 등의 이유 때문에 싱글 코어 멀티 스레딩은 스레드 생성 시간이 오히려 오버헤드로 작용해 단일 스레드보다 느리다.

<br/>
<br/>

# ✅ 멀티 스레드 모델
## User-Level Thread & Kernel-Level Thread
유저 스레드(User-level Thread)는 커널 위에서 커널의 지원 없이 유저 수준의 스레드 라이브러리(Thread Library)가 관리하는 스레드다.  
반면 커널 스레드(Kernel-level Thread)는 커널이 지원하는 스레드다. 이런 커널을 멀티 스레드 커널(Multithreded kernel)이라고 부른다.
  - 현대 대부분의 OS가 멀티 스레드 커널이다.

<br/>

![https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/bEiGnM/btreTJkupZk/NcPDSk0nWGuQofjqHPPF7k/img.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/bEiGnM/btreTJkupZk/NcPDSk0nWGuQofjqHPPF7k/img.png)

<br/>

커널 스레드를 사용하면 안정적이지만 유저 모드에서 커널 모드로 계속 바꿔줘야 하기 때문에 성능이 저하된다. 반대로 유저 스레드를 사용하면 안정성은 떨어지지만 성능이 저하되지는 않는다.  
유저 스레드와 커널 스레드는 서로 맵핑(Mapping)된다.
  - Non-Multithreaded kernels에서 유저 스레드는 일반적인 프로세스처럼 처리된다. 커널이 스레드를 인식할 수 없어 맵핑이 이루어지지 않기 때문이다.
  - Multithreded kernels에서는 유저 스레드와 커널 스레드는 무조건 관계가 존재한다.

유저 스레드와 커널 스레드 사이에 어떠한 관계가 항상 존재한다. 이 관계를 설계하는 여러 가지 방법이 있다.

<br/>

### Many-to-One Model
하나의 커널 스레드에 여러 유저 스레드를 연결하는 모델이다. 유저 공간의 스레드 라이브러리를 통해서 스레드가 관리되므로 효율적이다. 라이브러리를 위한 모든 코드나 자료구조가 유저 공간에 존재하므로 라이브러리의 함수 호출이 시스템 콜이 아니라 지역 함수 호출의 결과를 낳기 때문이다.  
반면, 한번에 한 유저 스레드만 커널에 접근할 수 있기 때문에 멀티 프로세서 시스템에서 병렬적인 수행을 할 수 없어 요즘에는 잘 사용되지 않는 방식이다. 한 유저 스레드의 시스템 콜로 인해 Block 되면 프로세스 전체가 Block 되기 때문이다.

<br/>

### One-to-One Model
하나의 커널 스레드에 하나의 유저 스레드가 대응하는 모델이다. 동시성(Concurrency)을 높여주고, 멀티 프로세서 시스템에서 동시에 여러 스레드를 수행할 수 있도록 해 준다.  
단점으로는, 유저 스레드를 늘리면 커널 스레드도 똑같이 늘어나는데, 커널 스레드의 생성은 오버헤드가 크기 때문에 성능 저하가 발생할 수 있다.

<br/>

### Many-to-Many Model
여러 유저 스레드에 더 적거나 같은 수의 커널 스레드가 대응하는 모델이다. 운영체제는 충분한 수의 커널 스레드를 만들 수 있으며, 커널 스레드의 구체적인 개수는 프로그램이나 작동 기기에 따라 다르다. 멀티 프로세서 시스템에서는 싱글 프로세서 시스템보다 더 많은 커널 스레드가 만들어진다.  
완전한 동시성은 아니지만, Many-to-one Model에 비해 더 높은 동시성을 갖는다. 그리고 One-to-One Model의 단점이었던 커널 스레드 생성의 오버헤드도 걱정할 필요 없다.

<br/>

### Two-level Model
Many-to-Many Model에서 확장된 개념이다. 특정 유저 스레드를 위한 커널 스레드를 별도로 제공하는 모델이다. 점유율이 높아야 하는 유저 스레드를 더 빠르게 처리할 수 있다.

<br/>
<br/>

# 🗣 면접 예상 질문

## Q1. 멀티 프로세스와 멀티 스레드의 차이를 설명해 주세요.
- 멀티 프로세스는 독립적인 자원을 사용함으로써 많은 메모리 공간을 차지하고 문맥 교환이 느린 반면에 멀티 스레드는 공유 자원으로 메모리 공간을 줄이고 문맥 교환 역시 빠르다.
- 멀티 프로세스는 독립적인 자원을 사용함으로써 다른 프로세스가 죽더라도 다른 프로세스에 영향을 끼치지 않는 반면에 멀티 스레드는 하나의 스레드가 오류로 종료되면 전체 스레드가 종료된다는 위험과 동기화의 문제가 있다.

<br/>

> 결론적으로 둘 다 동시에 여러 작업을 처리하지만 장단점이 있으므로 시스템의 특성에 맞게 선택하여 사용하기!
> 

<br/>

![https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/GBQLA/btrnxkBpfCk/QXNgbyD9qNRuAWmg2vkAHk/img.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/GBQLA/btrnxkBpfCk/QXNgbyD9qNRuAWmg2vkAHk/img.png)

<br/>

## Q2. 유저 스레드와 커널 스레드에 대해 설명해 주세요.
### 커널 모드와 유저 모드
- 메모리 영역은 사용자에 의해서 할당되는 메모리 공간인 유저 영역과 운영체제라는 하나의 소프트웨어를 실행시키기 위해서 필요한 메모리 공간인 커널 영역으로 나뉜다.
- 사용자가 사용하는 메모리 영역은 유저 영역이지만, C언어는 메모리 참조가 용이하기 때문에
안정성 제공 측면에서 커널 모드와 유저 모드가 사용된다.
- 기본적으로 유저 모드로 동작하다가 Windows 커널이 실행되어야 하는 경우에 커널 모드로의 전환이 일어난다.
- 커널 모드와 유저 모드의 차이는 유저 모드에서 동작할 때 커널 영역으로의 접근이 금지된다.
커널 모드일 때는 모든 영역의 접근이 허용된다.
- Windows에서 운영체제 차원에서 제공되는 시스템 함수들 중 일부는 호출 시 커널 모드로 동작한다.
주의할 점은 모드의 전환은 시스템에 부담을 준다.
- 커널 모드와 유저 모드를 제공하는 대상은 Windows 운영체제가 아닌 프로세서(Process)이다.
즉, 메모리 보호 기능이 CPU에 달려있다.

<br/>

### 커널 레벨 스레드와 유저 레벨 스레드
- 커널 레벨 스레드와 유저 레벨 스레드는 생성 주체가 누구냐에 따라 구분된다.
- 프로그래머 요청에 따라 스레드를 생성하고 스케줄링하는 주체가 커널이면 커널 레벨(Kernel Level) 스레드라고 한다.
- 커널이 스레드 모델을 지원하지 않거나 제공하는 스레드 모델이 마음에 들지 않을 경우, 커널에 의존적이지 않은 형태로 스레드의 기능을 제공하는 라이브러리를 활용할 수 있는데 이러한 방식으로 제공되는 스레드가 유저 레벨(User Level) 스레드이다.

<br/>

### 커널 레벨 스레드와 유저 레벨 스레드의 장단점
- 커널 레벨 스레드의 장점은 커널이 직접 제공해 주기 때문에 안정성과 다양한 기능이 제공된다.
- 커널 레벨 스레드의 단점은 유저 모드에서 커널 모드로의 전환이 빈번하게 이뤄져 성능 저하가 발생한다.
- 유저 레벨 스레드의 장점은 커널은 스레드의 존재조차 모르기 때문에 모드 간의 전환이 없고 성능 이득이 발생한다.
- 유저 레벨 스레드의 단점은 하나의 스레드가 커널에 의해 블로킹 되면 프로세스 전체가 블로킹되고, 이를 해결하려면 프로그래밍이 어려워지고 커널 레벨 쓰레드에 비해 결과 예측이 어려워진다.

<br/>
<br/>

# 🗂 참고
- [멀티 프로세싱 vs 멀티 프로그래밍 vs 멀티 태스킹 vs 멀티 스레딩 (tistory.com)](https://sorjfkrh5078.tistory.com/56)
- [[OS] 멀티스레딩의 장점 & 단점 ? (velog.io)](https://velog.io/@hkh1213/%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%94%A9%EC%9D%98-%EC%9E%A5%EC%A0%90-%EB%8B%A8%EC%A0%90)
- [[운영체제(OS)] 4. 멀티쓰레드(Multithreaded Programming) (rebro.kr)](https://rebro.kr/174)
- [[운영체제] 다중쓰레드모델(Multithreading model)이란? (tistory.com)](https://code-lab1.tistory.com/44)
- [사용자 수준 Thread와 커널 수준 Thread 의 차이점은? – JungHyun Baek – Developer from South Korea (junghyun100.github.io)](https://junghyun100.github.io/%EC%82%AC%EC%9A%A9%EC%9E%90%EC%88%98%EC%A4%80ThreadVS%EC%BB%A4%EB%84%90%EC%88%98%EC%A4%80Thread/)
- [멀티 태스킹, 멀티 프로그래밍, 멀티 프로세싱, 멀티 코어, 멀티 프로세스, 멀티 스레드 (tistory.com)](https://aeroej.tistory.com/152)
- [[운영체제 OS]멀티스레딩(Multi-threading)이란? (tistory.com)](https://technote-mezza.tistory.com/69)
