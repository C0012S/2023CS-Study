# 💡 페이징 & 세그먼테이션

# ✅ 사전 지식
## 메모리 관리 기법
1. 연속 메모리 기법
    - 프로그램 전체가 메모리에 연속적으로 할당
    - 고정 분할 기법
        - 메모리가 고정된 파티션으로 분할
        - 내부 단편화 발생
    - 동적 분할 기법
        - 파티션들이 동적으로 생성되고 자신의 크기와 같은 파티션에 메모리 할당
        - 외부 단편화 발생
2. 불연속 메모리 기법
    - 프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법
    - Page : 프로세스를 고정된 크기로 나눈 블록
    - Frame : 메모리를 고정된 크기로 나는 블록
    - Segment : 서로 다른 크기의 논리적 블록

<br/>

## 가상 메모리
![https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/B8mdX/btrEc3rcdi7/YWqKXJZotCTpzXTM4kCeu1/img.jpg](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/B8mdX/btrEc3rcdi7/YWqKXJZotCTpzXTM4kCeu1/img.jpg)

<br/>

- 실제 메모리 크기와 관계없이 메모리를 사용할 수 있도록 가상 메모리 주소를 사용
- 프로세스의 일부분만 메모리에 로드하고 나머지는 보조 기억 장치(가상 메모리 공간)에 할당
- MMU(Memory Management Unit)를 통해 논리 주소, 물리 주소를 나누어서 사용
- 가상 주소를 주 기억 장치의 실제적인 주소로 매핑(Mapping)하는 방법을 통해 구현

<br/>

### 가상 메모리가 필요한 이유
- 물리 메모리의 한계
    - 모든 프로그램 코드를 물리 메모리에 올릴 수가 없다.
    - 그렇다고 프로그램을 교체하면서 올리면 메모리 교체 성능 문제가 발생한다.
- 가상 메모리의 장점
    - 프로그램 용량이 실제 물리 메모리보다 커도 된다.
    - 전체 프로그램이 물리 메모리에 올라와 있지 않아도 된다.
    - 더 많은 프로그램을 동시에 실행할 수 있다.
        - 응답 시간은 유지
        - CPU 이용률과 처리율은 증가
    - 즉, 다중 프로그래밍을 실현하기 위해 물리 메모리의 제약을 보완하고 프로세스 전체를 메모리에 올리지 않고도 실행할 수 있도록 해 준다.

<br/>

## 메모리 단편화
어떠한 프로그램을 실행할 때, 컴퓨터에서는 프로그램들을 메모리 공간에 연속적으로 할당하게 된다.  
만약 여러 프로그램들이 메모리에 할당되고 해제되는 것이 반복되다 보면 메모리 공간이 조각조각 나뉘게 되어 총메모리가 충분함에도 불구하고 프로그램에 메모리를 할당하는 것이 불가능한 상태가 발생하게 된다.  
이러한 현상을 바로 메모리 단편화라고 한다.  
메모리 단편화 해결 방법에는 페이징과 세그멘테이션이 있다.  
페이징과 세그멘테이션은 가상 메모리를 관리하는 기법으로 프로세스가 사용하는 메모리 공간을 잘게 나누어 비연속적으로 실제 메모리에 할당하는 메모리 관리 기법이다.

<br/>
<br/>

# ✅ 페이징
![https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/yaaix/btrEdsK3PPJ/0U6gkxhlTGah6p0kg4mrL1/img.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/yaaix/btrEdsK3PPJ/0U6gkxhlTGah6p0kg4mrL1/img.png)

<br/>

- 프로세스의 주소 공간을 고정된 사이즈의 페이지 단위로 나누어 물리적 메모리에 불연속적으로 할당하는 방식
    - 페이징 방식으로 메모리를 할당하게 되면 실제 프로세스가 실행될 때는 각각의 페이지들이 실제 메모리의 어디에 위치하고 있는지를 빠르게 알 수 있어야 한다.
    - 프로세스의 입장에선 자신이 사용하고 있는 메모리 공간이 흩어져 있는 페이지들이 아니라 하나의 연속된 메모리 공간으로 이해할 수 있어야지 프로그램 실행이 효율적이게 된다.        
        → 페이징은 프로세스가 바라보는 메모리 주소 공간(논리 주소)와 실제 메모리 주소 공간(물리 주소)를 구분하여 효율적인 메모리 할당과 효율적인 메모리 참조를 달성하고 있다.        
        - CPU는 논리 주소로 프로그램이 설정한 대로 연속적인 주소 값으로 명령을 내리고 이는 메모리로 가기 전에 각 페이지의 실제 메모리 주소가 저장되어 있는 테이블에서 물리 주소로 변경되어야 한다.
        - 논리 주소와 물리 주소가 분리되어 동적으로 논리 주소가 물리 주소에 재배치되면서 할당되는 것을 허용해야 하고, 모든 메모리 참조에서 주소 변환이 필요하기 때문에 MMU가 필요하다.
- 메모리는 Frame이라는 고정 크기로 분할되고, 프로세스는 Page라는 고정 크기로 분할된다.
- 페이지와 프레임은 크기가 같다.
- 페이지와 프레임을 대응시키는 page mapping 과정이 필요하여 paging table을 생성해야 한다.
- 연속적이지 않은 공간도 활용할 수 있기 때문에 외부 단편화 문제 해결
- 페이지 테이블에는 각 페이지 번호와 해당 페이지가 할당된 프레임의 시작 물리 주소를 저장

<br/>

> 프로세스의 크기가 페이지 크기의 배수가 아닐 경우 마지막 페이지에 내부 단편화가 발생하고 페이지의 크기가 클수록 내부 단편화가 커진다.  
> → 페이지 단위를 작게 하면 내부 단편화 문제도 해결할 수 있겠지만 page mapping 과정이 많아지므로 효율이 떨어진다.
> 

<br/>

## 프레임 & 페이지
![https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/bLkUHG/btrnVx3zJlB/WVQMspD9qmVyg62UTkKTW0/img.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/bLkUHG/btrnVx3zJlB/WVQMspD9qmVyg62UTkKTW0/img.png)

<br/>

- Frame : 페이지가 저장된 실제 물리 메모리의 위치 영역의 단위
- Page : 프로세스가 바라보고 있는 메모리 공간. 즉 논리 주소 공간의 단위
- Page table : 각각의 페이지가 실제 메모리에 어떤 프레임이 저장되는가에 대한 매핑 정보를 담고 있는 자료구조. 프로세스가 실행될 때 연속된 위치의 메모리라고 이해한 상태로 각각의 페이지가 어디에 있는지 빠르게 찾을 수 있도록 돕는다.
    - page table은 프레임 번호를 담고 있는 배열
    - page table의 index == 페이지 번호
    - page table의 value == 프레임 번호

<br/>

## 페이징의 주소 표현
- 이전의 주소 값이라는 것은 한 바이트의 위치를 나타내는 주소 값.
- 페이징 기법에서는 실제 어떤 변수(논리 주소)가 저장되어 있는 어떤 바이트 주소(물리 주소)를 알아야 되긴 하지만 이것들이 페이지 단위의 묶음으로 배치가 되기 때문에 먼저 페이지가 어디에 있는지를 알아내야 한다.
- 논리 주소 공간의 크기가 2^m이고, 페이지의 크기가 2^n일 때 상위 (m - n) 비트는 페이지 번호, 하위 n 비트는 오프셋이다.

<br/>

![https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/bahwml/btrnWSzouHH/Dk5FbnWjk2yxRFWSWteQp1/img.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/bahwml/btrnWSzouHH/Dk5FbnWjk2yxRFWSWteQp1/img.png)

<br/>

페이지 크기가 4KB, 메모리 크기가 256KB인 메모리 페이징 시스템의 경우  
- 페이지 프레임 수는?
    - 페이지 크기 : 4KB == 2^12Byte
    - 메모리 크기 : 256KB == 2^18Byte
    - 페이지 프레임 수는 메모리 전체 크기에 페이지가 최대 몇 개 들어 갈 수 있는지 묻고 있는 것이다.
    - 따라서 2^18/2^12 = 2^6 = **64 개**이다.
- 이 메모리 주소를 해결하는 데 필요한 비트 수는?
    - 메모리 주소를 모두 표현하기 위해서는 메모리가 2^18임을 알고 있고 결국 비트가 18 개가 있어야 2^18을 만족 할 수 있게 된다.
    - 따라서 **18 비트**가 있으면 된다.
- 페이지 번호에 사용하는 비트와 오프셋에 사용하는 비트는?
    - 페이지 번호를 나타내기 위한 비트        
        : 64개의 페이지를 나타내야 하기 때문에 2^6 → **6 비트**        
    - 오프셋에 사용되는 비트        
        : 하나의 페이지의 모든 위치를 나타내야 하기 때문에 2^12 → **12 비트**
        
<br/>

![https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/bT5kZG/btrnU563l11/UKnsSj5vXwHKUVET3Xx790/img.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/bT5kZG/btrnU563l11/UKnsSj5vXwHKUVET3Xx790/img.png)

<br/>

## 페이징의 한계 - 내부 단편화(Interner Fragment)
- 페이징의 방식으로는 외부 단편화 문제는 해결할 수 있지만, 내부 단편화 문제는 해결하지 못한다.
- 내부 단편화는 프로세스 크기가 페이지 크기의 배수가 아닐 경우, 마지막 페이지는 한 프레임(페이지)를 다 채울 수 없어서 발생하는 공간으로 메모리 낭비의 원인이 된다.
- ex : 페이지 크기가 4KB인데 10KB의 메모리를 필요하는 프로세스가 있다면?
    - 페이지가 2 개 하고 2KB가 할당되는 것이 아니라 3 개가 할당되어야 10KB메모리를 쓸 수 있다.
    - 마지막으로 할당된 페이지는 크기는 4KB이지만 실제 사용하고 있는 메모리는 2KB → 2KB만큼 메모리를 낭비하는 내부 단편화가 발생
- 페이지 크기를 작으면 내부 단편화가 감소가 되긴 하지만 이는 페이지 테이블 크기를 증가시킨다.
- 페이징에서는 내부 단편화를 해결할 방법이 없지만 내부 단편화는 외부 단편화에 비해 낭비되는 메모리 공간은 매우 적다. (내부 단편화의 최대 낭비 크기는 page size - 1. 반면 외부 단편화는 최대 전체 메모리의 1/3이 낭비)

<br/>

## 보호와 공유
### 보호(Protection)
- 모든 주소는 페이지 테이블을 경유하므로, 테이블을 이용해서 보호 기능을 수행할 수 있다.
- 대표적으로 페이지 테이블마다 r(read), w(write), x(excute) 비트를 두어 해당 비트가 켜져 있을 때 그 수행이 가능하도록 한다.
    - 만약 쓰기 비트가 꺼져있는 페이지에 쓰기작업을 시도하면 CPU에 인터럽트가 발생하여 ISR(Interrupt Service Routine)에서 강제로 해당 프로세스를 종료시킨다.

<br/>

### 공유(Sharing)
- 공유는 메모리 낭비를 방지하기 위함이다.
- 프로세스의 메모리는 code+data+stack 영역으로 나뉘는데 프로그램이 같다면 code 영역은 같을 것이다. 하나의 code 영역을 복수 개의 프로세스가 공유하여 메모리 낭비를 줄일 수 있다. 단, code가 공유되려면 변하지 않는 프로그램이어야 한다.
- 각각의 프로세스들의 특정 페이지가 실제 물리 메모리에 같은 프레임으로 연결되도록 페이지 테이블 정보를 가지고 있게 된다면 서로 다른 프로세스이지만 동일한 메모리를 사용할 수 있다.

<br/>
<br/>

# ✅ 세그멘테이션
물리적인 고정 크기로 분할하는 페이징과는 달리 프로그램의 논리적인 내용 단위로 프로세스의 메모리 공간을 분리하는 기법이다.

<br/>

![https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/22MDs/btrEcQMrq7W/FoKKXCHIBOvfcsu9YvU18k/img.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/22MDs/btrEcQMrq7W/FoKKXCHIBOvfcsu9YvU18k/img.png)

<br/>

- 프로세스를 서로 크기가 다른 논리적인 블록 단위인 세그먼트(Segment)로 분할하여 메모리에 할당
- 각 세그먼트는 연속적인 공간에 저장
- 세그먼트들의 크기가 서로 다르기 때문에 프로세스가 메모리에 적재될 때 빈 공간을 찾아 할당하는 기법
- 페이징과 마찬가지로 mapping을 위한 segment table 필요
- 페이징과 세그멘테이션을 구분하는 좋은 예시
    - 우리가 돼지를 잡아서 보관을 한다고 가정한다. 페이징의 방법을 사용하면 돼지를 모두 같은 단위로 잘라서 보관을 하는 것이다. 반면에 세그먼테이션은 부위별로 다른 크기로 잘라서 보관하는 것이다.
- 논리적 단위로는 method, procedure, function, object, variables, stack 등 함수 단위로 나눌 수 있고, C 컴파일러 관점에서는 코드, 전역 변수, 힙, 스택, 표준 C 라이브러리 단위로 구분 지어 나눌 수 있다.
- 논리적 내용의 단위(의미가 같은)로 자르기 때문에 세그먼트들의 크기는 일반적으로 같지 않다.
- 프로세스를 어떻게 자르는가에 대한 방법 빼고 메모리에 할당하는 방법에 대해서는 페이징과 방법이 같다. 세그멘테이션도 보호와 공유의 기능을 수행한다.
- 세그먼트의 논리 주소는 세그먼트의 이름(번호)와 오프셋으로 나뉜다.
- 세그먼트 테이블(Segment Table) : 세그먼트 테이블에서는 각각의 세그먼트가 차지하는 크기가 서로 다르기 때문에 세그먼트의 실제 메모리 위치 정보 + 끝 주소(크기) 정보를 포함되어 있다.

<br/>

> 프로세스가 필요한 메모리 공간만큼 메모리를 할당해주기 때문에 내부 단편화 문제는 발생하지 않지만, 중간에 메모리를 해제하면 생기는 외부 단편화 문제가 발생
> 

<br/>

## 세그멘테이션 한계 - 외부 단편화(External Fragment)
세그멘테이션 방식은 가변적인 크기를 가져가기 때문에 내부 단편화 문제는 해결하지만, 외부 단편화 문제가 발생할 수 있다.

<br/>

세그멘테이션과 페이징 기법은 모두 장단점을 가지고 있기 때문에 두 기법을 모두 사용하여 장점만을 가져와 단편화 문제를 효과적으로 해결할 수 있는 방법을 모색해 볼 수 있다.  
세그멘테이션은 보호와 공유 면에서 효과적이고, 페이징은 외부 단편화 문제를 해결하는데 효과적이다.

<br/>

![https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/4i8gO/btrnWS7btk8/Wmf4srbnWstvVS9ZxJOW20/img.jpg](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/4i8gO/btrnWS7btk8/Wmf4srbnWstvVS9ZxJOW20/img.jpg)

<br/>

- 프로세스를 처음에 세그먼트 단위로 자른다.
- 의미 있는 단위로 나누게 되면 보호와 공유를 하는 측면에서 이점을 가질 수 있게 된다.
- 세그먼트로 인한 외부 단편화 문제를 해결하기 위해 잘라진 세그먼트를 일정한 간격인 페이지 단위로 자르는 페이징 방법을 취한다.
- 이후 메모리에 적재하면 페이징의 일정 단위로 다시 잘렸기 때문에 외부 단편화가 발생하지 않는다

> 단, 이와 같은 경우는 테이블을 두 가지 모두 거쳐야 하므로 속도 면에서 조금 떨어진다.
> 

<br/>
<br/>

# ✅ 페이지와 세그멘테이션 차이점
- Paging은 고정 크기를 가진다.
- Segmentation은 가변 크기를 가진다.
- Paging은 내부 단편화 발생 가능, Segmentation은 외부 단편화 발생 가능

<br/>
<br/>

# 🗣 면접 예상 질문
## Q1. 메모리 단편화(Fragmentation)가 무엇인가요?
메모리 단편화는 메모리(RAM)의 공간이 여러 작은 공간으로 나뉘어져 사용되는 바람에 전체로 봤을 때 충분히 사용 가능한 메모리가 있음에도 불구하고 할당을 못하는 상태를 말한다.

<br/>
<br/>

## Q2. 외부 단편화와 내부 단편화는 무엇을 뜻하나요?
### 외부 단편화
외부 단편화는 메모리 단편화의 의미와 비슷하다.  
메모리 할당/해제 작업이 계속 진행될 때, 중간중간 사용 가능한 공간이 많이 존재해서 전체적으로 사용 가능한 메모리의 양은 충분하나 실제로 메모리를 할당할 수 없는 상태를 말한다.  
예를 들어, 아래와 같이 메모리가 존재한다고 가정한다.  
메모리의 총량은 50K, 각 10K의 메모리를 소비하는 작업이 4개 가동 중이므로 사용 가능한 메모리 총량은 10K가 되지만, 새로 요청하는 작업의 메모리는 5K로 작업을 가동시키기에는 5K의 공간이 없기 때문에 해당 작업을 수행하지 못하게 된다.

<br/>

### 내부 단편화
내부 단편화는 메모리를 할당하는 최소 블록의 크기에 비해 작업에 필요한 메모리의 양이 작은 경우, 남은 공간이 생겨 메모리를 낭비하게 되는 상황을 가리킨다.  
예를 들어, 어떤 작업을 위해 10K의 메모리를 할당해줬는데, 해당 작업이 실제 7K만 사용한다면 3K의 메모리 공간이 그저 낭비되고 있다. 이걸 모으면 충분한 메모리 양이 생기지만, 그러지 못하게 되는 상황을 가리킨다.

<br/>
<br/>

## Q3. 페이징 또는 세그멘테이션을 사용하는 이유는 무엇인가요?
프로그램을 실행하기 위해 코드를 디스크에서 메인 메모리로 적재하는 과정에서 단편화가 생길 수 밖에 없다.  
이렇게 단편화가 많이 발생하면 사용하지 못하는 메모리 공간이 많아져 낭비가 되므로 최대한 피해야 한다.  
최초 적합, 최적 적합, 압축 등의 방식을 통해 단편화를 해결할 수도 있지만, 메모리 계산의 비용이 적은 페이징 또는 세그멘테이션을 주로 사용한다.

<br/>
<br/>

## Q4. 페이징(Paging)이란 무엇인가요?
- 논리 주소 공간이 물리 메모리 공간에 연속적으로 들어가야 하는 제약을 해결하는 방법.
- 논리 주소 공간의 단위인 페이지를 물리 주소 공간 단위인 프레임에 매핑시킨다.
- 이를 위해선 논리 주소 공간과 물리 주소 공간을 분리해야 하며, 논리 주소와 물리 주소 변환을 위해 MMU(Memory Management Unit)의 도움을 받아야 한다.

<br/>
<br/>

## Q5. 페이징의 특징은 무엇인가요?
페이징은 프로그램을 실행할 때, 코드를 메모리에 적재하기 위해 사용하는 기법이며 불연속 메모리 관리 기법이라는 특징이 있다.  
다시 말해 프로그램 전체가 메모리에 연속적으로 올라가 있는 것이 아니라 페이지라는 고정된 크기로 분할되어 올라가 있다. 또한 페이징은 외부 단편화 문제를 해결할 수 있다.

<br/>
<br/>

## Q6. 페이징과 세그멘테이션의 차이를 설명해 주세요.
페이징과 세그멘테이션 모두 프로그램을 실행하기 위해 디스크에 있는 내용을 분할하여 메모리에 적재하는 불연속 메모리 관리 기법이다.  
둘의 차이는 프로그램을 분할하는 방식이다.  
페이징의 경우 프로그램을 같은 크기의 페이지로 분할하는 데에 비해, 세그멘테이션은 논리적 의미를 기준으로 세그먼트를 분할한다.

<br/>
<br/>

# 🗂 참고
- [[OS] 페이징(Paging)과 세그멘테이션(Segmentation) :: 코딩 공부 일지 (tistory.com)](https://cocoon1787.tistory.com/860)
- [[운영체제] 페이징과 세그멘테이션 (tistory.com)](https://bellog.tistory.com/159)
- [[운영체제] 페이징과 세그멘테이션 (tistory.com)](https://steady-coding.tistory.com/524)
- [[OS - Memory] 2020.11.20. 오늘의 면접 Q&A (tistory.com)](https://maivve.tistory.com/274)
- [[면접 예상 질문] 운영체제(2/3) - 무성이의 공부 블로그 (ddb8036631.github.io)](https://ddb8036631.github.io/question/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-2/)
