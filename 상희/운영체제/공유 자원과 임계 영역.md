# 💡 공유 자원과 임계 영역

# ✅ 공유 자원
## 공유 자원(Shared Resource)
공유 자원(Shared Resource)은 여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등을 말한다.  
공유 자원은 공동으로 이용되기 때문에 누가 언제 데이터를 읽거나 쓰느냐에 따라 그 결과가 달라질 수 있다. 따라서 프로세스들의 공유 자원 접근 순서를 정하여 예상치 못한 문제가 발생하지 않도록 해야 한다.

<br/>

## 경쟁 조건(Race Condition)
- 2개 이상의 프로세스가 공유 자원을 병렬적으로 읽거나 쓰는 상황
- 경쟁 조건이 발생하면 공유 자원 접근 순서에 따라 실행 결과가 달라질 수 있다.

<br/>

![https://yansigit.github.io/posts/공유자원과-임계구역/Untitled.png](https://yansigit.github.io/posts/공유자원과-임계구역/Untitled.png)

<br/>

위 그림을 보면 전역 변수 ‘예금’에 대해 두 프로세스가 모두 입금을 한다.  
똑같은 순서로 예금을 확인하고 입금액을 넣은 후 최종적으로 저장한다.

<br/>

프로세스 P1은 예금에 10만 원이 있는 것을 확인하고 10만 원을 입금했다.  
동시에 프로세스 P2도 예금에 10만 원이 있는 것을 확인하고 5만 원을 입금했다. 프로세스 P2는 10만 원에 5만 원을 더한 15만 원을 저장한 후 작업을 마쳤다.  
바로 이어서 프로세스 P1은 10만 원에 10만 원을 더한 20만 원을 저장한 후 작업을 마쳤다.  
예금은 원래 있던 10만 원에 프로세스 P1이 입금한 10만 원과 프로세스 P2가 입금한 5만 원을 합한 25만 원이 되어야 한다. 그런데 5만 원이 어디론가 사라지고 20만 원뿐이다.

<br/>

### 25만 원이 아닌 이유?
정상적으로 예금이 25만 원이 되려면 프로세스 P1이 작업을 마친 후 프로세스 P2가 예금 20만 원이 있는 것을 확인하고 5만 원을 입금해야 한다.  
또는 프로세스 P2가 작업을 마친 후 프로세스 P1이 예금 15만 원이 있는 것을 확인하고 10만 원을 입금해야 한다.  
하지만 두 프로세스가 예금 10만 원을 동시에 읽은 후 다른 프로세스의 작업을 무시하고 덮어쓰는 바람에 총액이 맞지 않는 문제가 발생하게 된 것이다.

<br/>

이처럼 **2개 이상의 프로세스가 공유 자원을 병행적으로 읽거나 쓰는 상황을 ‘경쟁 조건(Race Condition)이 발생했다’고 한다.**  
경쟁 조건이 발생하면 위의 그림과 같이 공유 자원 접근 순서에 따라 실행 결과가 달라질 수 있다.

<br/>
<br/>

# ✅ 임계 영역(Critical Section)

## 임계 영역(Critical Section)
- 공유 자원 접근 순서에 따라서 실행 결과가 달라지는 프로그램의 영역이다.
- 임계 구역에서는 프로세스들이 동시에 작업하면 안 된다.
    - 어떤 프로세스가 임계 구역에 들어가면 다른 프로세스는 기다려야 하며 임계 구역의 프로세스가 나와야 들어갈 수 있다.
- 전역 변수뿐만 아니라 하드웨어 자원을 사용할 때도 적용되는 개념이다.
    - ex : 프린터 1대를 여러 명이 동시에 사용하는 경우 프린터는 임계 구역이 된다.

<br/>

## 생산자 - 소비자 문제
임계 구역 관련 유명한 문제로 생산자 - 소비자 문제(Producer - Consumer Problem)가 있다.

<br/>

생산자 - 소비자 문제에서는 생산자 프로세스와 소비자 프로세스가 서로 독립적으로 작업을 한다.  
생산자는 계속 물건을 생산해서 버퍼에 넣고[input(buf)], 소비자는 계속 버퍼에서 물건을 가져온다[output(buf)].  
버퍼는 작업을 계속하기 위해 원형 버퍼(Circular Buffer)를 사용한다.  
버퍼의 크기 확인을 위해 sum이라는 전역 변수를 사용한다.

<br/>

![Untitled](https://yansigit.github.io/posts/%ea%b3%b5%ec%9c%a0%ec%9e%90%ec%9b%90%ea%b3%bc-%ec%9e%84%ea%b3%84%ea%b5%ac%ec%97%ad/Untitled%202.png)

<br/>

이 때 생산자와 소비자가 동시에 실행되면 문제가 발생한다. 생산자와 소비자가 전역 변수 sum에 접근하는 타이밍을 서로 맞추지 않았기 때문이다.

<br/>

- 생산자가 물건 하나를 buf 4에 저장했다. sum을 4로 바꿔야 하나 아직 바꾸지 못했다.
- 소비자가 물건 하나를 가져갔다. sum을 2로 바꿔야 하나 아직 바꾸지 못했다.
- 이 상태에서 sum 변경(sum = sum + 1;, sum = sum - 1;)을 동시에 실행하면 문제가 생긴다. 생산자와 소비자가 독립적이기 때문에 상대방이 sum을 바꾸려는 것을 모른 채 현재 상태인 sum = 3을 읽어서 작업한다.
- 생산자가 4로 늘린 후 소비자가 2로 줄이면 2가 저장되고, 반대의 경우 sum에 4가 저장된다.

<br/>

이처럼 임계 구역은 한 번에 하나의 프로세스만 사용해야 한다.

<br/>

하드웨어 자원의 경우에도 문제가 일어날 수 있다.

<br/>

## 임계 구역 해결 조건
임계 구역 문제를 해결하는 방법은 다음 세 가지 조건을 만족해야 한다.

<br/>

### 상호 배제(Mutual Exclusion)
한 프로세스가 임계 구역에 들어가면 다른 프로세스는 임계 구역에 들어갈 수 없다.

<br/>

### 한정 대기(Bounded Wating)
어떤 프로세스도 무한 대기(Infinite Postpone)하지 않아야 한다. 즉, 특정 프로세스가 임계 구역에 진입하지 못하면 안 된다.

<br/>

### 진행의 융통성(Progress Flexibility)
한 프로세스가 다른 프로세스의 진행을 방해해서는 안 된다.

<br/>
<br/>

# ✅ 임계 구역 해결 방법
가장 단순한 방법은 잠금(lock)을 이용하는 것이다. 임계 구역에 들어갈 때 잠금을 걸고, 나올 때 잠금 해제와 동시에 동기화 신호를 보낸다.

<br/>

## 기본 코드

```c
#include <stdio.h>

typedef enum {false, true} boolean;
extern boolean lock = false;
extern int balance;

main() {
    while(lock == true);
    lock = true;
    balance = balance + 10; /* 임계 구역 */
    lock = false;
}
```

<br/>

## 임계 구역 해결 조건을 고려한 코드 설계
### 상호 배제 문제
공유 변수로 잠금을 직접 구현했다.

![Untitled](https://yansigit.github.io/posts/%ea%b3%b5%ec%9c%a0%ec%9e%90%ec%9b%90%ea%b3%bc-%ec%9e%84%ea%b3%84%ea%b5%ac%ec%97%ad/Untitled%203.png)

<br/>

- `lock=true`인 경우 무한 루프 돌면서 대기
- `lock=false`인 경우 lock을 걸고 임계 구역에서 작업하다가 lock을 해제하고 나온다.

<br/>

문제점

![Untitled](https://yansigit.github.io/posts/%ea%b3%b5%ec%9c%a0%ec%9e%90%ec%9b%90%ea%b3%bc-%ec%9e%84%ea%b3%84%ea%b5%ac%ec%97%ad/Untitled%204.png)

<br/>

- `lock=false`일 때, `lock=true`로 걸고 임계 구역에 진입해야 하는데 그 직전에 타임아웃이 걸린다면?
    - 다른 프로세스도 임계 구역에 진입하게 되고, 해당 타임아웃으로 대기하고 있던 프로세스도 대기가 끝나 실행될 때 또 임계 구역에 진입해버린다
    - 동시에 임계 구역에 진입해버릴 수 있다는 것

<br/>

### 한정 대기 문제
상호 배제 조건을 충족하는 코드다.

![Untitled](https://yansigit.github.io/posts/%ea%b3%b5%ec%9c%a0%ec%9e%90%ec%9b%90%ea%b3%bc-%ec%9e%84%ea%b3%84%ea%b5%ac%ec%97%ad/Untitled%205.png)

<br/>

- 상호 배제 조건은 만족하지만, 여기서는 타임아웃 타이밍에 따라 상호 무한 루프에 빠질 수 있는 위험이 있다.

<br/>

### 진행의 융통성 문제
상호 배제와 한정 대기 조건을 만족하는 코드다.

![Untitled](https://yansigit.github.io/posts/%ea%b3%b5%ec%9c%a0%ec%9e%90%ec%9b%90%ea%b3%bc-%ec%9e%84%ea%b3%84%ea%b5%ac%ec%97%ad/Untitled%206.png)

<br/>

- 상호 배제와 한정 대기 조건을 만족
- 그러나 만약 P1이 자주 실행되어야 하는 상황이라면?
    - P1은 P2가 실행되어 락을 바꿔줄 때 까지 반드시 대기해야 한다. (반드시 번갈아가며 실행되어야 하므로)
    - 그러므로 진행의 융통성을 충족하지 않는다.

<br/>

### 하드웨어적인 해결 방법
임계 구역 문제는 알고리즘을 이용한 소프트웨어적인 해결 방법뿐만 아니라 하드웨어적인 방법으로도 간단히 해결할 수 있다.

<br/>

- while(lock == true); 문과 lock = true; 문을 한꺼번에 실행 : testandset(&lock) == true
    - 잠금이 걸렸는지 검사하는 while(lock == true); 문과 검사한 후 잠금 설정을 하는 lock = true; 문이 분리되어 실행되면(즉, 두 명령어 중간에 타임아웃이 걸리면) 문제가 발생한다.
    - 이 경우 하드웨어적으로 두 명령어를 동시에 실행하면 임계 구역 문제를 쉽게 해결할 수 있다.
    - 하드웨어의 도움을 받는 코드는 아래 그림의 오른쪽 코드이다.

![Untitled](https://yansigit.github.io/posts/%ea%b3%b5%ec%9c%a0%ec%9e%90%ec%9b%90%ea%b3%bc-%ec%9e%84%ea%b3%84%ea%b5%ac%ec%97%ad/Untitled%207.png)

<br/>

- 검사-지정(Test-and-Set) 코드를 이용하면 명령어 실행 중간에 타임아웃이 걸려 임계 구역을 보호하지 못하는 문제가 발생하지 않는다.
- 이 명령어는 원자성(쪼개질 수 없음)을 가져 중간에 인터럽트 될 수 없다.
- 방법은 편리하지만 바쁜 대기를 사용하여 검사하므로 자원 낭비의 문제가 있다. (성능 좋은 하드웨어에서는 바쁜 대기 없이 동기화해 주기도 함)

<br/>

지금까지 소개한 알고리즘은 임계 구역 해결 조건을 완벽하게 충족하지 못했다. 다음 소개할 피터슨 알고리즘과 데커 알고리즘은 이러한 문제를 해결했으나 구조가 복잡하여 현재 잘 사용되지 않는다.

<br/>

## 피터슨 알고리즘

![Untitled](https://yansigit.github.io/posts/%ea%b3%b5%ec%9c%a0%ec%9e%90%ec%9b%90%ea%b3%bc-%ec%9e%84%ea%b3%84%ea%b5%ac%ec%97%ad/Untitled%208.png)

<br/>

- 게리 피터슨(Gary Peterson)이 제안한 알고리즘
- 변수 `turn`은 두 프로세스가 동시에 lock을 설정하여 임계 구역에 못 들어가는 상황에 대비하는 장치
    - 두 프로세스가 동시에 lock을 설정했더라도 turn을 사용하여 다른 프로세스에게 양보

<br/>

### 한계
- 임계 구역 해결의 세 가지 조건을 모두 만족하지만 프로세스 수가 늘어나면 변수도 늘어나고 전체적인 알고리즘도 복잡해진다.
- 바쁜 대기를 사용하여 자원을 낭비한다. (while loop)
- 2개의 프로세스만 사용 가능하다. 여러 프로세스가 하나의 임계 구역을 사용하려면 공유 변수를 추가해야 한다.

<br/>

## 데커 알고리즘

![Untitled](https://yansigit.github.io/posts/%ea%b3%b5%ec%9c%a0%ec%9e%90%ec%9b%90%ea%b3%bc-%ec%9e%84%ea%b3%84%ea%b5%ac%ec%97%ad/Untitled%209.png)

<br/>

- 테오도뤼스 데커(Theodorus Dekker)가 제안한 알고리즘
- 하드웨어의 도움 없이도 임계 구역 문제를 해결할 수 있다.

<br/>

### 한계
- 임계 구역 해결의 세가지 조건을 모두 만족하지만 프로세스 수가 늘어나면 변수도 늘어나고 전체적인 알고리즘도 복잡해진다.
- 바쁜 대기를 사용하여 자원을 낭비한다. (while loop)

<br/>

## 세마포어(Semaphore)
- 에츠허르 데이크스트라(Edsger Dijkstra)가 제안한 알고리즘
- 앞의 알고리즘과 비교하여 간단하고 사용이 쉬우며, wakeup 신호를 사용하기 때문에 바쁜 대기를 하지 않아도 된다.

<br/>

![Untitled](https://yansigit.github.io/posts/%ea%b3%b5%ec%9c%a0%ec%9e%90%ec%9b%90%ea%b3%bc-%ec%9e%84%ea%b3%84%ea%b5%ac%ec%97%ad/Untitled%2010.png)

<br/>

세마포어가 어떻게 작동하는지 아래 그림의 세마포어 내부 코드를 통해 알아본다.
- **Semaphore(n)** : 전역 변수 RS를 n으로 초기화한다. RS는 현재 사용 가능한 자원의 수이다.
- **P()** : 잠금을 수행하는 코드로, RS가 0보다 크면(사용 가능한 자원이 있으면) 1만큼 감소시키고 임계 구역에 진입한다. 만약 RS가 0보다 작으면 0보다 커질 때까지 기다린다.
- **V()** : 잠금 해제와 동기화를 같이 수행하는 코드로, RS 값을 1 증가시키고 세마포어에서 기다리는 프로세스에게 임계 구역에 진입해도 좋다는 wake_up 신호를 보낸다.

![Untitled](https://yansigit.github.io/posts/%ea%b3%b5%ec%9c%a0%ec%9e%90%ec%9b%90%ea%b3%bc-%ec%9e%84%ea%b3%84%ea%b5%ac%ec%97%ad/Untitled%2011.png)

<br/>

- `P(`)와 `V()`의 내부 코드는 *검사와 지정*을 사용하여 분리 실행되지 않고 완전히 실행되게 해야 한다.
    - `P()`나 `V()`내부 코드가 실행되는 도중 다른 코드가 실행되면 *상호 배제*와 *한정 대기 조건*을 보장하지 못하기 때문

<br/>

### 한계
- 잘못된 사용으로 인해 임계 구역이 보호받지 못할 수 있다.
    - 사용자가 고의로 세마포어를 사용하지 않거나 사용 중에 실수를 한 경우
    - 즉 직접 변수에 접근하여 조작하기 때문에 위험하다.

<br/>

### 순서
1. 임계 구역 사용 전에 `Semaphore(n)` 로 초기화를 한다.
    1. `n`은 공유 가능한 자원의 수를 나타낸다. 전역변수 RS를 n으로 초기화 한다.
    2. ex : 프린터가 1대이면 1이고, 2대이면 2가 된다.
2. 초기화가 끝난 후 임계 구역에 들어가기 전 사용 중이라고 표시를 한다.
    1. `P()` : 잠금을 수행하는 코드
    2. RS가 0보다 크면(사용 가능한 자원이 있으면) 1을 감소시키고 임계 구역에 진입한다.
    3. RS가 0보다 작으면(사용 가능한 자원이 없으면) 0보다 커질 때 까지 기다린다.
3. 임계 구역을 나올 때 비었다고 표시한다.
    1. `V()` : 잠금 해제와 동기화를 같이 수행하는 코드
    2. RS값을 1 증가시키고 세마포어에서 기다리는 프로세스에게 임계 구역에 진입해도 좋다는 wake up 신호를 보낸다. — `wake_up()`

<br/>

## 모니터(Monitor)
### 세마포어의 잘못된 사용 예

![Untitled](https://yansigit.github.io/posts/%ea%b3%b5%ec%9c%a0%ec%9e%90%ec%9b%90%ea%b3%bc-%ec%9e%84%ea%b3%84%ea%b5%ac%ec%97%ad/Untitled%2015.png)

<br/>

1. 실수하여 세마포어를 쓰지 않고 공유자원에 접근하는 경우
    - 그냥 바로 접근이 가능해 임계 구역 보호 불가능
2. 실수하여 `P()`를 두 번 써버림
    - `wake_up()` 신호가 발생되지 않아 세마포어에서 대기하고 있는 프로세스들 무한 대기
3. `V()`와 `P()`를 반대로 사용
    - 역시 상호 배제가 적용되지 않은 상태로 되어버리므로 임계 구역 보호 불가능

<br/>

공유 자원을 사용할 때 모든 프로세스가 세마포어 알고리즘을 따른다면 굳이 P()와 V()를 사용할 필요 없이 자동으로 처리하면 된다. 이를 실제로 구현한 것이 모니터(Monitor)이다.

<br/>

### 모니터(Monitor)
- 공유 자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만 제공하여 자원을 보호하고 프로세스 간에 동기화를 시킨다.
- 시스템 호출과 같은 개념이다.
- 사용자 입장에서는 복잡한 코드를 실행하지 않아서 좋고 시스템 입장에서는 임계 구역을 보호할 수 있어서 좋다.

<br/>

### 작동 원리

![Untitled](https://yansigit.github.io/posts/%ea%b3%b5%ec%9c%a0%ec%9e%90%ec%9b%90%ea%b3%bc-%ec%9e%84%ea%b3%84%ea%b5%ac%ec%97%ad/Untitled%2016.png)

<br/>

- 임계 구역으로 들어가려는 프로세스는 직접 `P()` 혹은 `V()`를 사용하지 않는다.
- 대신 모니터에게 작업을 **요청**
- 모니터는 요청받은 작업을 모니터 큐에 저장하고 순서대로 처리, 결과만 프로세스에 알려 준다.

<br/>

### 순서
1. 임계 구역으로 지정된 변수나 자원에 접근하고자 하는 프로세스는 직접 `P()`나 `V()`를 사용하지 않고 모니터에 작업 요청을 한다.
    1. 잠금이나 세마포어를 사용하지 않고 `increase()` 문을 사용
    2. `wait()` : 모니터 큐에서 자신의 차례가 올 때까지 기다린다. — `P()`
    3. `signal()` : 모니터 큐에서 기다리는 다음 프로세스에 순서를 넘겨준다. — `V()`
2. 모니터는 요청받은 작업을 모니터 큐에 저장한 후 순서대로 처리하고 그 결과만 해당 프로세스에 알려준다.

<br/>
<br/>

# 🗣 면접 예상 질문
## Q1. 임계 구역 해결 조건엔 무엇이 있는지 말씀해 주시고, 설명해 주세요.
임계 구역 해결 조건엔 상호 배제, 한정 대기, 진행의 융통성이 있다.

<br/>

### 상호 배제(Mutual Exclusion)
한 프로세스가 임계 구역에 들어가면 다른 프로세스는 임계 구역에 들어갈 수 없다.

<br/>

### 한정 대기(Bounded Wating)
어떤 프로세스도 무한 대기(Infinite Postpone)하지 않아야 한다. 즉, 특정 프로세스가 임계 구역에 진입하지 못하면 안 된다.

<br/>

### 진행의 융통성(Progress Flexibility)
한 프로세스가 다른 프로세스의 진행을 방해해서는 안 된다.

<br/>

## Q2. 뮤텍스와 세마포어의 차이점을 설명해 주세요.
뮤텍스와 세마포어 모두 임계 구역을 보호하기 위한 방법이다.

<br/>

### 뮤텍스(Mutex)
뮤텍스는 자원에 대한 접근을 동기화하기 위해 사용되는 **상호 배제 기술**이다.  
뮤텍스는 **Locking 메커니즘**으로 락을 걸은 쓰레드만이 임계 영역을 나갈 때 락을 해제할 수 있다. 뮤텍스는 wait와 signal이라는 원자적 연산을 사용한다.  
뮤텍스 구현 알고리즘으로는 **데커 알고리즘, 피터슨 알고리즘**이 존재한다.

<br/>

### 뮤텍스와 세마포어의 차이점
- 가장 큰 차이점은 동기화 대상의 개수이다. 뮤텍스는 동기화 대상이 오직 1개일 때 사용하고, 세마포어는 동기화 대상이 1개 이상일 때 사용한다.
- 0과 1로 이루어진 바이너리 세마포어는 뮤텍스가 될 수 있다. 하지만 뮤텍스는 세마포어가 될 수 없다.
- 뮤텍스는 소유하고 있는 프로세스/스레드만이 lock을 해제할 수 있다.

<br/>
<br/>

# 🗂 참고
- [[OS] 공유 자원과 임계구역 (velog.io)](https://velog.io/@suyeonme/OS-%EA%B3%B5%EC%9C%A0-%EC%9E%90%EC%9B%90%EA%B3%BC-%EC%9E%84%EA%B3%84%EA%B5%AC%EC%97%AD)
- [운영체제 - 공유자원과 임계구역 (yansigit.github.io)](https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B3%B5%EC%9C%A0%EC%9E%90%EC%9B%90%EA%B3%BC-%EC%9E%84%EA%B3%84%EA%B5%AC%EC%97%AD/)
- [[운영체제] 5.2 공유 자원과 임계구역 :: 이름짓기어려워 (tistory.com)](https://chosh95.tistory.com/340)
- [책] 쉽게 배우는 운영체제
- [임계구역 해결 방법 (velog.io)](https://velog.io/@mardi2020/%EC%9E%84%EA%B3%84%EA%B5%AC%EC%97%AD-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95)
- [[운영체제] 프로세스 동기화 (velog.io)](https://velog.io/@cheal3/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94)
- [[CS Study : OS] 공유자원과 임계영역 (velog.io)](https://velog.io/@jsb100800/CS-%EC%8A%A4%ED%84%B0%EB%94%94-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B3%B5%EC%9C%A0%EC%9E%90%EC%9B%90%EA%B3%BC-%EC%9E%84%EA%B3%84%EC%98%81%EC%97%AD)
