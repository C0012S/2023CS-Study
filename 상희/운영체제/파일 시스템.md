# 💡 파일 시스템

# ✅ 파일과 파일 시스템
## 파일 시스템의 개요
### 파일 시스템의 개념
컴퓨터 시스템에는 다양한 종류의 파일이 있으며 이러한 파일은 하드디스크나 CD 같은 제 2 저장장치에 보관된다.  
보관 과정에서 사용자가 직접 개입하면 다른 사용자의 파일을 훼손하거나 저장장치 내부를 어지럽혀 문제를 일으킬 수 있다.  
운영체제는 이를 막기 위해 사용자가 직접 파일을 보관하거나 접근하지 못하도록 한다. 대신 파일을 보관하고 관리하는 파일 관리자를 두어 저장장치의 전체 관리를 맡기는데 이를 **파일 시스템**이라고 한다.  
파일 시스템에서 파일 관리자는 사용자의 요청에 따라 파일을 저장하거나 파일의 내용을 읽어 온다. 

<br/>

저장장치에서는 파일 관리자가 파일 테이블을 사용하여 파일을 관리한다.  
파일 관리자는 파일 테이블을 사용하여 파일의 생성, 수정, 삭제 등을 수행한다. 또한 사용자가 파일을 사용하고자 할 때, 읽기, 쓰기, 실행과 같은 다양한 접근 방법을 제공한다.  
사용자가 특정 파일에 접근하려면 파일 관리자로부터 파일에 접근할 수 있는 권한(키)을 획득해야 하는데, 파일 접근 권한을 파일 디스크립터(File Descriptor)라고 한다. 

<br/>

### 파일 시스템의 기능

파일 테이블의 구성은 운영체제마다 다른데 공통적으로 다음과 같은 기능을 수행한다.

| 기능 | 설명 |
| --- | --- |
| 파일 구성 | 사용자의 요구에 따라 파일과 디렉터리를 만든다. |
| 파일 관리 | 파일 생성, 수정, 삭제 등의 관리를 하고, 수시로 조각 모음을 하여 사용자가 파일에 빨리 접근할 수 있도록 한다. |
| 접근 권한 관리 | 다른 사용자로부터 파일을 보호하기 위해 접근 권한을 관리한다. |
| 접근 방법 제공 | 파일을 읽고 쓰고 실행할 수 있도록 사용자에게 접근 방법을 제공한다. |
| 무결성 보장 | 파일의 내용이 손상되지 않도록 무결성을 보장한다. |
| 백업과 복구 | 사고로부터 파일을 보호하기 위해 백업과 복구 작업을 한다. |
| 암호화 | 파일을 암호화하여 악의적인 접근으로부터 파일을 보호한다. |

> 해당 표는 파일 시스템의 기능을 나타낸다.
> 

<br/>

파일 시스템은 파일을 생성하고, 사용자가 파일을 편리하게 관리할 수 있도록 디렉터리 구조를 제공한다.  
또한 여러 종류의 파일을 구분하기 위해 파일 이름과 확장자를 만들어 관리한다.  
파일 이름, 파일 크기, 생성 날짜 등 다양한 파일 정보는 파일 헤더에 저장하여 관리한다.

<br/>

### 블록과 파일 테이블
데이터는 운영체제와 저장장치 간에 블록 단위로 전송된다.

<br/>

#### 블록
- 저장장치에서 사용하는 가장 작은 단위이다.
- 한 블록에 주소 하나가 할당된다.
    - 메모리는 바이트 단위로 저장되고, 하드디스크의 물리적인 구조 상 가장 작은 저장 단위는 섹터이다.
    - 메인 메모리는 보통 수 기가바이트지만, 하드디스크는 수 테라바이트이므로 메모리보다 수백 배 이상 크다.
    - 따라서 **섹터마다 주소를 부여하면 너무 많은 양의 주소가 필요**하기 때문에 **파일 관리자는 여러 섹터를 묶어 하나의 블록으로 만들고, 블록 하나에 주소 하나를 배정**한다.
- 블록의 크기는 시스템마다 다르다.
    - 사용자는 포맷을 할 때, 시스템이 정한 기본 블록 크기를 사용할 수도 있고, 4,096B~64KB의 다양한 블록 크기를 직접 지정할 수도 있다.
    - 블록 크기를 작게 설정하면 내부 단편화 현상이 줄어들어 저장장치를 효율적으로 쓸 수 있다. 그러나 파일이 여러 블록으로 나뉘어 파일 입출력 속도가 느려진다.
    - 큰 파일을 많이 사용할 때는 블록 크기를 크게 잡는 것이 좋다.
- 포맷을 하면 각 블록에 번호가 매겨지고, 파일 테이블에는 파일이 어떤 블록에 있는지 명시된다.

<br/>

## 파일 분류와 확장자
파일은 논리적인 데이터의 집합으로 하드디스크나 CD 같은 제 2 저장장치에 저장된다.  
모든 파일은 0과 1의 비트 패턴(Bit Pattern)으로 이루어지며 운영체제 입장에서는 크게 실행 파일과 데이터 파일로 나뉜다.  
- 실행 파일
    - 운영체제가 메모리로 가져와 CPU를 이용하여 작업을 하는 파일이다.
    - 즉, 사용자의 요청으로 프로세스가 된 파일을 말한다.
- 데이터 파일
    - 실행 파일이 작업하는 데 필요한 데이터를 모아 놓은 파일이다.
    - 데이터 파일은 스스로 프로세스가 될 수 없고, 운영체제가 전송하거나 보관만 할 뿐 특별하게 다루지 않는다.
    - 운영체제가 바라보는 모든 데이터 파일은 0과 1로 이루어진 데이터의 덩어리일 뿐이다.
    - ex : 이미지 뷰어 프로그램의 사진 파일, 뮤직 플레이어의 음악 파일, 워드프로세서의 문서 파일 등
    - 컴퓨터에는 다양한 종류의 데이터 파일이 존재한다.
        - 이미지 파일
            - ex : BMP, JPG, GIF, PNG 등
        - 음악 파일
            - EX : MP3, WAV, Ogg, AAC, FLAC 등

<br/>

다양한 종류의 데이터 파일을 구별하기 위해 파일에는 헤더가 달려 있다.  
파일 헤더에는 파일의 이름, 버전, 크기, 만든 날짜, 접근 권한 등의 정보가 저장된다.  
모든 종류의 파일은 각각 고유한 헤더를 가지고 있다.

<br/>

모든 파일 이름에는 확장자가 붙는다.  
파일에 확장자를 붙이면 파일의 성격을 알 수 있다.  
ex : anim.jpg의 anim은 파일 이름, 확장자는 jpg이다.

<br/>

- 현재 많이 사용되는 파일의 확장자들

| 파일 | 확장자 | 설명 |
| --- | --- | --- |
| 실행 파일 | exe, com | 유닉스에는 실행 파일 확장자가 없음 |
| 소스코드 파일 | c, cpp, pas, a, java | 다양한 소스코드의 확장자 |
| 라이브러리 파일 | lib, a, dll | 소스코드를 위한 라이브러리의 확장자 |
| 배치 파일 | bat, sh, csh | 초기 배치 파일의 확장자 |
| 문서 파일 | txt, doc, hwp, pdf, ps 등 | 문서 데이터 파일의 확장자 |
| 동영상 파일 | avi, asf, mkv, mov, rmv | 동영상 데이터 파일의 확장자 |
| 음악 파일 | wav, mp3, ogg, flc, aac | 음악 데이터 파일의 확장자 |
| 이미지 파일 | bmp, gif, jpg, tiff, png | 이미지 데이터 파일의 확장자 |
| 압축 파일 | rar, zip, arc, al | 압축 파일의 확장자 |

실행 파일을 제외한 나머지는 모두 데이터 파일의 확장자이다.  
윈도우 실행 파일은 exe나 com과 같이 확장자가 정해져 있으나 유닉스는 특별히 정해진 확장자가 없다.

<br/>

## 파일 이름과 연결 프로그램
대부분의 파일 이름은 ‘파일 이름.확장자’의 형태로 구성된다.  
파일 이름 관련 유의 사항은 다음과 같다.  
- 파일 확장자 글자 수
- 파일 이름 마지막 마침표는 확장자로 인식
- 파일 이름은 경로 이름을 포함하여 최대 255 자
- 특수 문자 및 대문자와 소문자

<br/>

윈도우에서 실행 파일을 더블클릭하면 프로세스가 생성되어 실행된다.  
데이터 파일을 더블클릭하면 해당 파일을 사용하는 응용 프로그램이 실행된다. (이러한 프로그램을 연결 프로그램이라고 한다.)  
실행 파일과 데이터 파일은 둘 다 더블클릭하면 실행되기 때문에 데이터 파일을 실행 파일로 착각하기 쉽다.  
데이터 파일이 필요로 하는 응용 프로그램을 운영체제가 실행하는 것이지 데이터 파일 자체가 실행되는 것은 아니다.

<br/>

윈도우에서 데이터 파일에 연결된 응용 프로그램을 바꾸고 싶을 때는 연결 프로그램을 변경하면 된다.  
주의할 점은 확장자를 바꾼다고 해서 내용이 바뀌지는 않는다는 것이다.

<br/>

## 파일 속성
대부분의 파일은 아래와 같은 속성을 가지고 있다.

| 속성 | 특징 |
| --- | --- |
| name | 파일의 이름 |
| type | 파일의 종류 |
| size | 파일의 크기 |
| time | 파일의 접근 시간 |
| location | 파일의 위치 |
| accessibility | 파일의 접근 권한 |
| owner | 파일의 소유자 |

파일 속성은 각 파일 헤더에 기록되며 운영체제는 이러한 파일 헤더를 파일 테이블에서 관리한다.

<br/>

운영체제가 관리하는 파일 헤더 외에 데이터 파일마다 자신에게 필요한 파일 속성을 따로 정의하여 사용하기도 한다. 이는 파일의 고유 헤더에 기록된다.  
아래 그림은 파일 헤더와 고유 헤더의 관계를 보여 준다.  
![Untitled](https://shacoding.com/wp-content/uploads/2022/06/image-94.png)

<br/>

- 파일 헤더
    - 파일 테이블에서 관리한다.
    - 파일의 이름, 종류, 크기, 시간, 접근 권한 등과 같은 일반적인 내용이 담겨 있다.
    - 파일이 저장장치의 몇 번째 블록에 있는지에 대한 정보도 가지고 있다.
- 고유 헤더
    - 데이터 파일에는 응용 프로그램이 필요로 하는 고유 헤더가 따로 달려 있다.
    - 고유 헤더에는 파일의 버전 번호, 크기, 특수 정보 등 응용 프로그램이 필요로 하는 정보가 담겨 있다.
    - 파일을 복구할 때 유용하게 사용된다.
        - 만약 빠른 포맷을 했다면 파일 테이블에 있던 파일 헤더가 사라질 것이다. 그러나 빠른 포맷은 파일 테이블만 지운 것이지 실제 데이터를 지우지는 않는다.
        - 파일을 휴지통에 버리는 것도 마찬가지이다. 파일 테이블에서만 사라질 뿐 실제 데이터는 지워지지 않는다.
        - 따라서 데이터 파일의 고유 헤더는 저장장치에 남아 있다.
        - 파일 복구 프로그램은 모든 블록을 찾아다니면서 고유 헤더에 있는 정보를 이용하여 파일을 원래 상태로 복원한다.

<br/>

## 파일 작업의 유형
파일을 지우거나 이름을 바꾸는 것과 같이 파일을 변경하는 것을 파일 작업 또는 파일 연산(File Operation)이라고 한다.  
파일 작업은 크게 파일 자체를 변경하는 작업과 파일 내용을 변경하는 작업으로 나눌 수 있다.

<br/>

### 파일 자체를 변경하는 작업
파일 자체를 변경하는 작업의 종류는 아래 표와 같다.

| 작업 | 설명 |
| --- | --- |
| open | 파일을 연다. |
| close | 파일을 닫는다. |
| create | 새로운 파일을 생성한다. |
| remove | 파일을 이동한다. |
| copy | 파일을 복사한다. |
| rename | 파일의 이름을 변경한다. |
| list | 파일을 나열한다. |
| search | 파일을찾는다.  |

윈도우 [파일 탐색기]에서 이루어지는 작업을 생각하면 이해하기 쉬울 것이다.

<br/>

### 파일 내용을 변경하는 작업
파일 내용을 변경하는 작업은 프로세스 입장에서 수행하는 것이다.  
아래 표와 같이 주로 함수 형태이다.

| 작업 | 설명 |
| --- | --- |
| open() | 파일을 연다. |
| create() | 새로운 파일을 생성한다. |
| close() | 파일을 닫는다. |
| read() | 파일 내용을 읽는다. |
| write() | 파일에 새로운 내용을 쓴다. |
| update() | 파일 내용 중 일부를 변경한다. |
| insert() | 파일에 새로운 내용을 추가한다. |
| delete() | 파일 내용 중 일부를 지운다. |

<br/>

파일에 접근하려면 open(). create() 함수를 사용하여 운영체제로부터 이용 권한을 획득해야 한다.  
작업이 끝나면 close() 함수를 사용하여 파일의 작업이 끝났다는 것을 운영체제에 알려야 한다.  
파일 이용 권한은 파일 디스크립터를 통해 얻는다.

<br/>

open() 또는 create() 함수로 정당하게 파일 이용 권한을 획득하면 read(), wirte(), update(), insert(), delete()도 할 수 있다.  
update(), insert(), delete() 연산은 read() 또는 write()로도 구현 가능하다. 

<br/>

## 파일 구조
파일은 하나의 데이터 덩어리이다.  
파일 구조는 이 데이터 덩어리를 어떻게 구성하느냐에 따라 순차 파일 구조, 인덱스 파일 구조, 직접 파일 구조로 나눌 수 있다.

<br/>

### 순차 파일 구조
- 일반 파일은 기본적으로 순차 파일 구조(Sequential File Structure)이다.
- 순차 파일 구조는 파일 내용이 하나의 긴 줄로 늘어선 형태이다.
- 대표적인 예로 카세트 테이프가 있다.
    - 10 곡이 담긴 카세트테이프를 재생하면 1 번 곡부터 10 번 곡까지 순서대로 음악이 흘러나온다.
    - 원하는 음악을 들으려면 테이프를 앞으로 감거나(Forward) 뒤로 감아서(Backward) 원하는 위치로 가야 한다.
    - ex : 3 번 곡을 듣고 있다가 7 번 곡을 들으려면 빨리 감기를 하고 1 번 곡을 들으려면 되감기를 한다.
    - 이러한 접근 방식을 순차 접근(Sequential Access)이라고 한다.
- 사용자의 파일 작업
    - 사용자가 파일 작업을 하려면 open() 또는 create() 명령을 사용하여 운영체제로부터 이용 권한을 얻어야 한다.
    - 운영체제는 파일 이용 허가를 내리면서 파일 디스크립터를 사용자에게 준다.
    - 파일 디스크립터는 파일의 맨 앞에 위치한다.
    - 순차 파일 구조의 읽기, 쓰기 작업도 카세트 테이프의 재생(Play) 버튼과 녹음(Record) 버튼이 눌렸을 때 앞으로 전진하는 것처럼 같은 방식으로 진행된다.
        - 사용자가 read() 또는 write() 명령을 내리면 파일 디스크립터가 계속 전진한다.
    - 작업을 하다가 특정 위치로 파일 디스크립터를 옮겨야 할 때는 lseek() 명령을 사용한다.

<br/>

![Untitled](https://shacoding.com/wp-content/uploads/2022/06/image-95.png)

<br/>

#### 순차 파일 구조의 장점
- 모든 데이터가 순서대로 기록되기 때문에 저장 공간에 낭비되는 부분이 없다.
- 구조가 단순하여 테이프는 물론 플로피디스크나 메모리를 이용한 저장 장치에도 적용할 수 있다.
- 순서대로 데이터를 읽거나 저장할 때 매우 빠르게 처리된다.

<br/>

#### 순차 파일 구조의 단점
- 파일에 새로운 데이터를 삽입하거나 삭제할 때 시간이 많이 걸린다.
    - 중간에 데이터를 삽입하려면 그 뒤에 있는 데이터를 뒤로 밀어 빈 공간을 만들어야 한다.
    - 중간의 데이터를 삭제했을 때는 남은 빈 공간을 메우기 위해 그 뒤에 있는 데이터를 앞으로 당겨야 한다.
    - 따라서 순차 파일 구조는 데이터의 변경이 잦은 경우에 적당하지 않다.
- 특정 데이터로 이동할 때 직접 접근이 어렵기 때문에 앞에서부터 순서대로 움직여야 한다.
    - 따라서 순차 파일 구조는 데이터 검색에 적당하지 않다.

<br/>

### 인덱스 파일 구조
- 순차 파일 구조의 단점을 해결한 파일 구조
    - 순차 파일 구조에서는 특정 데이터에 접근하기 위해 앞에서부터 순차적으로 이동해야 한다.
    - 인덱스 파일 구조(Index File Structure)는 이러한 단점을 해결한 파일 구조이다.
    - 순차 파일 구조에 인덱스 테이블을 추가하여 순차 접근과 직접 접근이 가능하다.
- 인덱스 순차 접근(Indexed Sequential Access)
    - 인덱스를 이용한 접근 방식을 인덱스 순차 접근이라고 한다.
    - 이렇게 구성된 파일을 ISAM(Index Sequential Access Method) 파일이라고 한다.
- 순차 접근과 직접 접근이 모두 가능하다.
    - 현대의 파일 시스템은 인덱스 파일 구조로, 파일을 저장할 때는 순차 파일 구조로 저장하고 파일에 접근할 때는 인덱스 테이블을 보고 원하는 파일에 직접 접근한다.

<br/>

#### 인덱스 파일 구조의 장점
- 인덱스 테이블을 여러 개 만들면 다양한 접근이 가능하다.
    - 이러한 특징 때문에 데이터베이스 같이 데이터의 빠른 접근이 필요한 시스템에 사용된다.
- 데이터베이스에 인덱스 테이블을 만들면 사용자의 질의에 빠르게 응답할 수 있다.
    - 데이터베이스의 인덱스 구축에는 다양한 알고리즘이 사용된다.
    - 인덱스 구성 방법에 따라 데이터의 접근 속도가 달라진다.
    - 일반적으로 B 트리를 이용하여 인덱스를 구성한다.

<br/>

#### 인덱스 파일 구조의 단점
- 색인 영역이나 오버플로 영역을 설정해야 하므로 기억 공간이 필요하다.
- 색인을 이용하여 참조하기 때문에 접근 시간이 직접 파일보다 느리다.

<br/>

### 직접 파일 구조
직접 파일 구조(Direct File Structure)는 저장하려는 데이터의 특정 값에 어떤 관계를 정의하여 물리적인 주소로 바로 변환하는 파일 구조이다.  
특정 함수를 이용하여 접근이 가능하며 이때 사용하는 함수를 해시 함수(Hash Function)이라고 한다.

<br/>

![Untitled](https://shacoding.com/wp-content/uploads/2022/06/image-97.png)

<br/>

#### 직접 파일 구조의 장점
- 해시 함수를 이용하여 주소를 변환하기 때문에 접근이 매우 빠르다.

<br/>

#### 직접 파일 구조의 단점
- 직접 파일 구조를 제대로 작성하려면 해시 함수의 선정이 매우 중요하다. 전체 데이터가 고르게 저장될 수 있는 해시 함수를 찾아야 한다.
- 해시 함수를 잘 찾았더라도 저장 공간이 낭비되는 문제도 있다.
    - [그림 11-12]의 해시 데이터를 보면 모든 주소에 일정량의 데이터가 고르게 저장되지 않고 들쑥날쑥하게 저장되어 있다. 이런 경우, 빈 공간이 생겨서 저장장치의 이용 효율이 떨어진다.

<br/>
<br/>

# ✅ 디렉터리의 구조
## 디렉터리의 개념
디렉터리는 관련 있는 파일을 하나로 모아 놓은 곳이다.  
1 개 이상의 자식 디렉터리(Sub Directory)를 가질 수 있고, 또한 1 개 이상의 파일을 가질 수 있다.  
하나의 디렉터리에는 여러 개의 파일과 자식 디렉터리가 존재한다.

<br/>

디렉터리는 여러 층으로 구성할 수 있다.  
최상위에 있는 디렉터리를 루트 디렉터리(Root Directory)라고 한다.

<br/>

![Untitled](https://shacoding.com/wp-content/uploads/2022/06/image-99.png)

<br/>

## 디렉터리 파일
디렉터리도 파일이다.  
일반 파일에는 데이터가 담겨 있고, 디렉터리에는 파일 정보가 담겨 있다.  
디렉터리도 일반 파일과 마찬가지로 헤더를 가진다.  
디렉터리 헤더에는 디렉터리의 이름, 만든 시간, 접근 권한 등의 정보가 기록되어 있다.

<br/>

## 경로
경로는 파일이 전체 디렉터리 중 어디에 있는지를 나타내는 정보이다.  
한 디렉터리에는 같은 이름을 가진 파일이 존재할 수 없지만, 서로 다른 디렉터리에는 같은 이름의 파일이 존재할 수 있다.

<br/>

- 절대 경로(Absolute Path)
    - 루트 디렉터리를 기준으로 파일의 위치를 나타내는 방식이다.
    - 루트 디렉터리에서 시작하는 절대적인 위치를 의미한다.
- 상대 경로(Relative Path)
    - 현재 있는 위치를 기준으로 파일의 위치를 표시할 수 있다.

<br/> 

디렉터리를 이동할 때는 cd(Change Directory) 명령을 사용한다.  
cd에는 절대 경로와 상대 경로를 모두 사용할 수 있다.  
현재 위치보다 아래에 있는 데이터에 접근할 때는 상대 경로를 사용한다.   
다른 디렉터리로 이동할 때는 절대 경로를 사용한다.

<br/>

## 디렉터리 구조
### 1 단계 디렉터리 구조
초기 파일 시스템의 디렉터리는 1 단계 구조였다.  
파일이 많지 않아서 많은 디렉터리가 필요하지 않았기 때문이다.  
1 단계 디렉터리 구조에서는 루트 디렉터리에 새로운 디렉터리를 만들 수 있다.  
그러나 디렉터리 안에 자식 디렉터리를 만들 수는 없다.  
최대 1 단계만 구현이 가능하며 디렉터리 안에는 파일만 존재한다. 

<br/>

### 다단계 디렉터리 구조
1 단계 디렉터리 구조는 매우 단순하지만 파일이 많아지면 불편하여 다단계 디렉터리 구조가 등장하게 되었다.  
다단계 디렉터리 구조는 루트 디렉터리를 시작점으로 여러 단계의 디렉터리가 가지처럼 뻗어 있어 나무를 뒤집어 놓은 것 같아 트리 디렉터리 구조라고도 한다.  
단계 확장에 제약이 없고 디렉터리에 파일과 디렉터리를 둘 다 저장할 수 있다.

<br/>

아래 그림은 순환이 없기 때문에 트리(순환이 없는 그래프) 구조이다.

![Untitled](https://shacoding.com/wp-content/uploads/2022/06/image-99.png)

그러나 오늘날의 디렉터리 구조에는 순환이 있다.  
기본적으로 트리 구조이지만 디렉터리와 디렉터리를 연결하는 링크가 있기 때문이다.  
ex : 윈도우의 바로가기 (유닉스 운영체제에서도 ln 명령어를 사용하면 윈도우의 바로가기와 같은 링크를 만들 수 있다.)

<br/>

## 마운트
### 파티션
- 파티션은 논리적인 디스크 분할로, 하나 또는 여러 개의 디스크를 파티션으로 나누어 사용할 수 있다.
- 윈도우
    - ex : C 드라이브, D 드라이브, E 드라이브, etc…
    - 예시와 같이 파티션이 사용자에게 노출되면 사용하기 불편하다.
    - 윈도우에서 각 파티션이 따로 보이는 이유는 파티션마다 파일 테이블이 따로 존재하기 때문이다.
    - 초기 윈도우에서는 파일 시스템의 최대 디스크 크기가 제한되었기 때문에 파티션을 나누어 파티션마다 서로 다른 파일 테이블을 사용해야 했다.
- 유닉스
    - 유닉스의 경우 서버용으로 만들어진 운영체제이므로 파일 테이블의 크기에 제한이 없다.
    - 하나의 파일 테이블로 여러 개의 디스크 혹은 파티션을 통합하여 관리할 수 있다.
    - 하나의 파일 테이블에 여러 개의 파티션을 붙여서 사용하는데, 마운트는 이렇게 여러 개의 파티션을 통합하는 명령어이다.

<br/>

### 마운트
- /mnt를 마운트 연결 지점(Mounting Point)라고 부른다.
- 마운트를 사용하면 디렉터리를 이동할 때마다 다른 파티션으로 넘어가지만, 사용자는 이를 알지 못한다.
    - 사용자에게는 한 파티션으로 보이기 때문에 몇 개의 파티션이 합쳐져 있는지 모르는 것이다.
- 마운트를 사용하면 파티션이 몇 개라도 하나로 통합할 수 있다.
- CD-ROM이나 USB 메모리 같은 외부 저장장치도 마운트로 파티션에 붙이고 마운트 해제(Un-Mount)로 분리할 수있다.
    - 보통 유닉스 운영체제에서는/dev 아래에 외부 저장장치를 마운트하여 사용한다.

<br/>
<br/>

# ✅ 디스크 파일 할당
## 연속 할당과 불연속 할당
파일 시스템은 기본적으로 메인 메모리 시스템과 유사하다.  
전체 디스크 공간을 같은 크기로 나누고 각 공간에 주소를 붙여서 관리한다.  
같은 크기로 나뉜 공간 하나를 블록이라고 한다.  

<br/>

파일 시스템은 파일의 이름과 해당 파일이 시작하는 블록 주소를 가진 파일 테이블을 관리한다.  
응용 프로그램이 어떤 파일에서 데이터를 읽고자 하면 파일 관리자는 파일 테이블에서 해당 파일의 블록 주소를 찾아 그 위치에서 데이터를 읽어온다.  
파일 테이블은 파티션 당 하나씩 존재하며 각 파티션의 맨 앞 부분에 위치한다.

<br/>  

일반적으로 하나의 파일은 여러 개의 블록을 사용한다.  
여러 개의 블록을 어떻게 연결하는지에 따라 연속 할당과 불연속 할당 방식으로 구분된다.  

<br/>

### 연속 할당(Contigous Allocation)
- 연속 할당은 파일을 구성하는 데이터를 디스크상에 연속적으로 배열하는 간단한 방식이다.
- 파일의 시작 블록만 알면 전체 파일을 찾을 수 있으나 실제로 사용되지 않는다.
    - 파일을 저장하거나 삭제하다 보면 빈 공간이 생기는데, 디스크에 남은 공간 중 파일의 크기와 맞는 연속된 공간이 없을 때는 연속 할당이 불가능하기 때문이다.

<br/>

### 불연속 할당(Non-Contigous Allocation)
- 불연속 할당은 비어 있는 블록에 데이터를 분산하여 저장하고 이에 관한 정보를 파일 시스템이 관리하는 방식이다.
- 대표적으로 연결리스트를 이용한 연결 할당과 인덱스를 이용한 인덱스 할당이 있다.

<br/>

#### 연결 할당(Linked Allocation)
- 연결 할당은 **파일에 속한 데이터를 연결 리스트로 관리**하는 방식이다.
    - 파일 테이블에는 시작 블록에 대한 정보만 저장하고, 나머지 데이터는 시작 블록부터 연결하여 저장한다.
    - 파일의 맨 끝에 해당하는 블록에는 링크 대신 널을 삽입한다.
    - 연결 할당 방식은 체인으로 연결한 것처럼 보여서 체인 할당(Chained Allocation)이라고 한다.
- 연결 할당 방식은 테이블 형태로 관리된다.
    - ex : 윈도우의 FAT
    - 테이블을 이용한 방식의 단점은 하나의 파티션이 사용할 수 있는 디스크 용량이 테이블의 주소 크기로 제한된다는 것이다.
        - 현재 윈도우 운영체제는 64bit 주소를 지원하는 NTFS 파일 시스템을 사용하고 있다.

<br/>

#### 인덱스 할당(Indexed Allocation)
연결 리스트를 이용한 불연속 할당 방식은 구현이 간편하지만 최대 할당 크기에 제한이 있다는 것이 문제이다.  
이러한 문제를 해결하기 위해 인덱스를 이용한 인덱스 할당 방식이 사용된다. 

<br/>

![Untitled](https://shacoding.com/wp-content/uploads/2022/06/image-101.png)

<br/>

인덱스 할당 방식에서는 테이블의 블록 포인터가 데이터 블록을 연결하는 것이 아니라, 데이터의 인덱스를 담고 있는 인덱스 블록을 연결한다.  
인덱스 블록은 실제 데이터의 위치에 관한 정보를 순서대로 보관하고 있다.

<br/>

##### I-node
인덱스 할당 방식에서 테이블이 꽉 차서 더 이상 데이터를 연결할 수 없을 때는 인덱스 블록을 연결하는 간접 인덱스 블록(Indirect Index Block)을 만들면 테이블을 무한히 확장할 수 있다.  
이러한 방식을 사용하는 파일 시스템은 유닉스 운영체제의 I-node이다.

<br/>

I-node 테이블은 파일 제어 블록(File Control Block), 블록 포인터(Block Pointer), 간접 포인터(Indirect Pointer), 이중 간접 포인터(Doubly Indirect Pointer), 삼중 간접 포인터(Triply Indirect Pointer)로 구성된다.  
- 파일 제어 블록
    - 파일 소유자와 각종 속성을 나타낸다.
    - 파일에 대한 모든 권한의 정보를 포함하고 있기 때문에 슈퍼 블록(Super Block)이라고도 한다.
- 블록 포인터
    - 데이터가 있는 블록의 위치를 직접 연결하는 포인터이다.
- 간접 포인터
    - 크기가 작은 파일은 직접 연결된 블록 포인터로 접근할 수 있다.
    - 하지만 파일 크기가 커서 블록 포인터가 다 차면 인덱스 블록을 생성한 후 간접 포인터를 생성하여 인덱스 블록을 연결한다.
- 이중/삼중 간접 포인터
    - 보통의 경우 인덱스 블록 하나는 256 개의 블록을 지정할 수 있다.
    - 파일 크기가 커서 인덱스 블록 하나로도 다 연결할 수 없는 경우에는 이중 간접 포인터를 사용하고, 이보다 더 필요한 경우에는 삼중 간접 포인터를 사용하여 연결한다.
    - 이중 간접 포인터는 256 × 256 개의 인덱스 블록을, 삼중 간접 포인터는 256 × 256 × 256 개의 인덱스 블록을 연결할 수 있다.

<br/>

###### I-node 파일 시스템의 특징
- 파일 크기가 작은 경우 블록을 직접 연결하여 빠르게 접근한다.
- 파일 크기가 큰 경우 인덱스 블록과 이를 연결하는 간접 포인터를 이용하여 확장한다.

<br/>

## 디스크의 빈 공간 관리
디스크는 같은 크기의 블록으로 나뉘며 블록 하나의 크기는 1~8KB 정도이다.  
블록 하나의 크기를 크게 잡으면 적은 주소로 많은 양의 데이터를 관리할 수 있지만 낭비하는 공간이 생긴다.  
블록 하나의 크기를 작게 잡으면 많은 양의 블록 포인터가 필요하다.  
각 블록에 블록의 크기보다 작은 파일을 저장할 경우 낭비되는 공간이 생긴다.  
이렇게 낭비되는 공간을 **내부 단편화**라고 한다.

<br/>

디스크에 파일을 저장할 때마다 모든 테이블을 뒤져서 빈 공간을 찾는 것은 비효율적이다.  
디스크의 내부 단편화를 줄이고 빈 공간을 효율적으로 관리하기 위해 파일 시스템은 빈 블록의 정보만 모아 놓은 빈 공간 리스트(Free Block List)를 유지한다.

<br/>

![Untitled](https://shacoding.com/wp-content/uploads/2022/06/image-102.png)

<br/>

### 디스크 복구나 휴지통에서 삭제한 파일을 되살리는 것이 가능한 이유
블록의 내용을 지우지 않고 빈 공간 리스트에 삽입하는 것은 해당 블록에 새로운 데이터를 덮어쓰지 않는 한 원래 데이터를 복구할 수 있는 여지를 남긴다.  
또한 빈 공간 리스트를 보고 새로운 블록을 할당할 때는 리스트에 먼저 들어온 블록부터 할당한다. (나중에 들어온 블록부터 할당한다면 하드디스크의 특정 섹터만 계속 사용하게 될 것이다.)  
어떤 데이터를 지우고 새로운 데이터를 디스크에 넣을 때 방금 지워진 블록에 할당되는 것이 아니라 리스트에 있던 블록 중 맨 앞에 있는 블록에 할당된다.  
이러한 특징 때문에 디스크 복구나 휴지통에서 삭제한 파일을 되살리는 것이 가능한 것이다.

<br/>

### 파일 시스템 오류를 수정하는 명령어
운영체제는 파일 시스템의 오류를 수정하는 명령어를 가지고 있다.  
윈도우의 파일 시스템 오류 복구 명령은 디스크 오류 검사(chkdsk)이고, 유닉스의 경우는 fsck이다.  
디스크 오류가 복구되면 사용할 수 있는 공간이 늘어나기도 한다.

<br/>
<br/>

# 🗂 참고
- [책] 쉽게 배우는 운영체제
- [OS - 파일 시스템 - SHA Computing (shacoding.com)](https://shacoding.com/2022/06/11/os-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C/)
- [[운영체제] 파일의 구조(순차 파일, 직접 파일, 색인 순차 파일) (itnovice1.blogspot.com)](http://itnovice1.blogspot.com/2019/08/blog-post_28.html)
