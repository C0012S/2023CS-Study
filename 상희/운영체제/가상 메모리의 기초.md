# 💡 가상 메모리의 기초

# ✅ 가상 메모리의 개요
컴퓨터마다 물리 메모리 즉, 실제 메모리의 크기가 다르다.  
가상 메모리(Virtual Memory)는 크기가 다른 물리 메모리에서 일관되게 프로세스를 실행할 수 있는 기술이다.

<br/> 

## 가상 메모리 시스템
### 가상 메모리의 개념
- 메모리의 크기는 컴퓨터마다 다른데 운영체제가 물리 메모리의 크기에만 의존한다면 2GB의 메모리에서 동작하는 프로그램이 1GB의 메모리에서는 동작하지 않을 수 있다.
- 프로그래머 또한 메모리 크기에 맞는 응용 프로그램만 개발해야 하는데 실제로 메모리 크기를 고려하여 프로그래밍하기란 어렵다.
    - 사용할 수 있는 배열의 개수가 한정되거나 특정 변수에 접근할 수 없다는 제약은 프로그래머에게 큰 장벽이다.
- 현대 메모리 관리의 가장 큰 특징은 물리 메모리의 크기와 프로세스가 올라갈 메모리의 위치를 신경 쓰지 않고 프로그래밍하도록 지원한다는 것이다.
    - 이러한 메모리 시스템을 가상 메모리라고 부른다.
- **가상 메모리**는 물리 메모리의 크기와 상관없이 프로세스에 커다란 메모리 공간을 제공하는 기술이다.
    - 프로세스는 운영체제가 어디에 있는지, 물리 메모리의 크기가 어느 정도인지 신경 쓰지 않고 메모리를 마음대로 사용할 수 있다.

<br/> 

### 가상 메모리의 크기와 주소
- 가상 메모리 시스템의 모든 프로세스는 물리 메모리와 별개로 자신이 메모리의 어느 위치에 있는지 상관없이 0 번지부터 시작하는 연속된 메모리 공간을 가진다.
    - 논리 주소와 유사하지만 한 가지 차이점이 있다.
        - 논리 주소는 물리 메모리의 주소 공간에 비례하다.
        - 가상 주소는 물리 메모리 공간이 아닌 가상의 주소 공간을 가진다.

<br/> 

아래 그림은 가상 메모리의 구성을 나타낸 것이다.  
가상 메모리는 크게 프로세스가 바라보는 메모리 영역과 메모리 관리자가 바라보는 메모리 영역으로 나뉜다.

![Untitled](https://velog.velcdn.com/images/sunnamgung8/post/d3f6e3e4-7185-4dc3-bca2-f3d320fd7914/image.png)

> 왼쪽이 프로세스가 바라보는 메모리 영역, 오른쪽이 메모리 관리자가 바라보는 메모리 영역이다.
> 

<br/> 

- 이론적으로 가상 메모리는 무한대의 크기이지만, 실제로 가상 메모리의 최대 크기는 그 컴퓨터 시스템이 가진 물리 메모리의 최대 크기로 한정된다. 즉, CPU의 비트에 따라 결정된다.
    - 32bit CPU의 경우 32bit로 표현할 수 있는 최댓값인 2^32 - 1(16 진수로 FFFFFFFF) 즉, 약 4GB가 메모리의 최대 크기이며 가상 메모리의 최대 크기도 약 4GB이다.
- 가상 메모리는 실제로 사용할 수 있는 최대 크기의 제약에도 불구하고 이론적으로 무한대의 크기가 있는 것처럼 구현할 수 있는 이유는 다음과 같다.
    - 가상 메모리 시스템에서는 물리 메모리의 내용 중 일부를 하드디스크의 일부 공간 즉, 스왑 영역으로 옮긴다.
    - 스왑 영역은 하드디스크에 존재하지만 메모리 관리자가 관리하는 영역으로서 메모리의 일부이며 가상 메모리의 구성 요소 중 하나이다.
    - 메모리 관리자는 **물리 메모리의 부족한 부분을 스왑 영역으로 보충**한다.
    - 즉, 물리 메모리가 꽉 찼을 때, 일부 프로세스를 스왑 영역으로 보내고(스왑아웃), 몇 개의 프로세스가 작업을 마치면 스왑 영역에 있는 프로세스를 메모리로 가져온다.(스왑인)

<br/> 

> 가상 메모리의 크기  
> : 가상 메모리에서 메모리 관리자가 사용할 수 있는 메모리의 전체 크기는 물리 메모리(실제 메모리)와 스왑 영역을 합한 크기이다.
> 

<br/> 

- 가상 메모리 시스템에서 메모리 관리자는 물리 메모리와 스왑 영역을 합쳐서 프로세스가 사용하는 **가상 주소를 실제 메모리의 물리 주소로 변환**하는데 이러한 작업을 **동적 주소 변환(Dynamic Address Translation, DAT)**이라고 한다.
    - 동적 주소 변환을 거치면 프로세스가 아무 제약 없이 사용자의 데이터를 물리 메모리에 배치할 수 있다.
    - 이 과정에서 메모리 관리자는 물리 메모리를 어떤 방법으로 나눌지, 사용자 프로세스를 어디에 배치할지, 부족한 물리 메모리를 어떻게 처리할지 등의 복잡한 문제를 처리한다.

<br/> 

### 가상 메모리의 메모리 분할 방식
실제 메모리에 있는 물리 주소 0 번지는 운영체제 영역이므로 일반 프로세스가 사용할 수 없다.  
따라서 가상 메모리 시스템에서는 운영체제를 제외한 나머지 메모리 영역을 일정한 크기로 나누어 일반 프로세스에 할당한다.  
메모리 분할 방식은 크게 가변 분할 방식과 고정 분할 방식으로 나뉘며 가상 메모리 시스템도 마찬가지이다.  
가상 메모리 시스템에서 가변 분할 방식을 이용한 메모리 관리 기법은 세그먼테이션, 고정 분할 방식을 이용한 메모리 관리 기법은 페이징이라고 한다.  

<br/> 

세그먼테이션 기법은 가변 분할 방식의 단점인 외부 단편화 등의 문제 때문에 잘 사용되지 않는다.  
페이징 기법은 페이지 관리에 어려움이 있다.  
따라서 가상 메모리 시스템에서는 두 기법의 단점을 보완한 세그먼테이션-페이징 혼용 기법을 주로 사용한다.

<br/> 

- 가상 메모리와 물리 메모리  

| 구분 | 가상 메모리 | 물리 메모리 |
| --- | --- | --- |
| 최대 메모리 크기 | CPU의 비트 값에 의존 | CPU의 비트 값에 의존 |
| 메모리 분할 방식 | 세그먼테이션 | 가변 분할 방식 |
|  | 페이징 | 고정 분할 방식 |
|  | 세그먼테이션-페이징 혼용 기법 |  |
| 주소 지정 방식 | 가상 주소 | 절대 주소, 상대 주소 |

<br/> 

## 매핑 테이블의 필요성과 역할
메모리를 관리할 때 매핑 테이블을 작성하여 관리한다.  
가상 메모리 시스템에서 가상 주소는 실제 물리 주소나 스왑 영역 중 한 곳에 위치하며 메모리 관리자는 가상 주소와 물리 주소를 일대일 매핑 테이블로 관리한다. 

<br/> 

아래 그림은 메모리 메핑 테이블을 나타낸 것으로 가상 주소가 물리 메모리의 어느 위치에 있는지 알 수 있다.  

![Untitled](https://shacoding.com/wp-content/uploads/2022/06/image-29.png)

<br/> 

- 가상 주소상의 프로세스 A는 물리 메모리의 세그먼트 0에 위치한다.
- 프로세스 B는 세그먼트 1에 위치한다.
- 프로세스 D의 경우 물리 메모리가 아니라 스왑 영역에 있다.
- 프로세스 A의 어떤 값이 필요할 때는 물리 메모리의 세그먼트 0에서 원하는 데이터를 가져오면 된다.

<br/> 

매핑 테이블은 위의 그림처럼 물리 메모리가 세그먼테이션으로 분할된 경우뿐 아니라 페이징으로 분할된 경우에도 똑같은 방식으로 적용된다.  
페이징 기법에서 사용하는 매핑 테이블은 페이지 매핑 테이블(Page Mapping Table) 또는 페이지 테이블이라고 부른다.  
세그먼테이션 기법에서 사용하는 매핑 테이블은 세그먼테이션 매핑 테이블(Segmentation Mapping Table) 또는 세그먼테이션 테이블이라고 부른다. 

<br/> 
<br/> 

# ✅ 페이징 기법
페이징 기법은 고정 분할 방식으로 메모리를 분할하여 관리한다.

<br/> 

## 페이징 기법의 구현
페이징 기법은 고정 분할 방식을 이용한 가상 메모리 관리 기법으로 물리 주소 공간을 같은 크기로 나누어 사용한다.

<br/> 

아래 그림에서 왼쪽의 가상 주소는 프로세스 입장에서 바라본 메모리 공간으로 항상 0 번지부터 시작한다.  

![Untitled](https://shacoding.com/wp-content/uploads/2022/06/image-30.png)

- 가상 주소의 분할된 각 영역은 **페이지**라고 부르며 첫 번째 영역은 페이지 0, 두 번째 영역은 페이지 1과 같이 번호를 매겨 관리한다.
    - 물리 메모리의 각 영역은 가상 주소의 페이지와 구분하기 위해 **프레임(Frame)**이라고 부른다.
    - 프레임도 페이지와 마찬가지로 번호를 매겨 관리한다.
    - 페이지와 프레임의 크기는 같다.
- 위 그림의 화살표는 가상 주소의 각 페이지가 물리 메모리의 어디에 위치하는지를 나타낸다.
- 페이지와 프레임은 크기가 같기 때문에 페이지는 어떤 프레임에도 배치될 수 있다.
    - 위 그림에서는 무작위로 배치하여 페이지 0은 프레임 2에, 페이지 1은 프레임 3에, 페이지 3은 프레임 1에 있다.
    - 모든 페이지의 위치 정보 즉, 어떤 페이지가 어떤 프레임에 있는지에 대한 연결(매핑) 정보는 페이지 테이블에 담겨 있다.
- 페이지 테이블은 하나의 열(column)로 구성된다.
    - 모든 페이지의 정보를 순서대로 가지고 있기 때문에 위에서부터 차례대로 페이지 0, 페이지 1, 페이지 2…와 같은 프레임 번호를 가지고 있어 추가 열이 필요 없다.
    - 위의 그림에서 페이지 테이블의 첫 번째 칸에 있는 2는 페이지 0이 프레임 2에 있다는 의미이다.
- 페이지 테이블에는 숫자만 있는 것이 아니다.
    - 위 그림의 페이지 5는 물리 메모리에 없기 때문에 페이지 테이블에 **invalid**라고 표시되어 있다.
    - invalid는 해당 페이지가 스왑 영역에 있다는 의미이다.

<br/> 

## 페이징 기법의 주소 변환
### 주소 변환 과정
아래 그림은 페이징 기법에서 가상 주소가 물리 주소로 어떻게 변환되는지를 보여 준다.

![Untitled](https://shacoding.com/wp-content/uploads/2022/06/image-31.png)

- 가상 주소 공간과 물리 주소 공간을 독같이 10B로 나누었고, 이에 따라 한 페이지 또는 한 프레임은 총 10 개의 주소를 가진다.
- 즉, 페이지 0에는 0~9 번지의 10 개 주소가, 페이지 1에는 10~19 번지의 10 개 주소가 있다.
- 물리 주소 공간도 마찬가지로 각 프레임에 10 개의 주소가 있다.

<br/> 

프로세스가 30 번지의 내용을 읽으려고(Read) 할 때, 가상 주소를 물리 주소로 변환하는 과정은 다음과 같다.  
1. 가상 주소 30 번지가 어느 페이지에 있는지 찾는다. 30 번지는 페이지 3의 0 번째 위치에 있다.
2. 페이지 테이블의 페이지 3으로 가서 해당 페이지가 프레임 1에 있다는 것을 알아낸다
3. 최종적으로 물리 메모리 프레임 1의 0 번째 위치에 접근한다. 이 주소가 가상 주소 30 번지의 물리 주소이다.

<br/> 

프로세스가 가상 주소 18 번지에 어떤 값을 저장하려고(Write) 할 때의 주소 변환 과정은 다음과 같다.  
1. 가상 주소 18 번지가 어느 페이지에 있는지 찾는다. 18 번지는 페이지 1의 8 번째 위치에 있다.
2. 페이지 테이블의 페이지 1로 가서 해당 페이지가 프레임 3에 있다는 것을 알아낸다.
3. 프로세스가 저장하려는 값을 프레임 3의 8 번 위치에 저장한다.

<br/> 

### 정형화된 주소 변환
페이징 기법에서는 가상 주소를 VA = <P, D>로 표현한다.  
VA는 가상 주소(Virtual Address), P는 페이지(Page), D는 페이지의 처음 위치에서 해당 주소까지의 거리(Distance)를 의미한다.  
> D를 오프셋(Offset, 변위)이라고 정의하기도 한다.
> 

<br/> 

위의 그림([8 - 6] 그림)에서 가상 주소 30 번지를 VA = <P, D> 방식으로 정의하면 VA = <3, 0>으로 작성할 수 있다.  
이는 가상 주소 페이지 3의 0 번째 주소라는 의미이다.  
페이지 하나의 크기를 10B로 규정했기 때문에 정형화된 표기법으로 작성하기가 쉽다.

<br/> 

페이징 기법에서의 주소 변환은 가상 주소 VA = <P, D>를 물리 주소 PA = <F, D>로 변환하는 것이다.  
PA는 물리 메모리의 주소를 가리키는 용어로 물리 주소 또는 실제 주소라고 한다.  
PA = <F, D>에서 F는 프레임(Frame), D는 프레임의 처음 위치에서 해당 주소까지의 거리(Distance)를 의미한다.  
VA = <3, 0>이 PA = <1, 0>으로 변환되었다는 것은 가상 주소 30 번지가 물리 주소 프레임 1의 0 번 위치로 변환되었다는 말이다.

<br/> 

페이징 기법의 주소 변환은 다음과 같이 정의할 수 있다.  
VA = <P, D> —> PA = <F, D>

<br/> 

아래 그림은 페이징 기법의 정형화된 주소 변환 과정을 보여 준다.

![Untitled](https://shacoding.com/wp-content/uploads/2022/06/image-32.png)

- VA = <P, D>가 PA = <F, D>로 변환될 때 페이지 테이블을 사용하여 P는 F로 바꾸고 D는 변경 없이 그대로 쓴다.
- D를 변경하지 않는 이유는 페이지와 프레임의 크기를 똑같이 나누었기 때문이다.

<br/> 

페이지 테이블을 이용하면 간단하게 가상 주소를 물리 주소로 변환할 수 있다.  
페이지 테이블에서 페이지 번호를 찾아 해당 프레임 번호를 쫓아가면 된다.  
페이지 테이블은 페이지 번호, 프레임 번호로 구성되며 각각의 한 줄은 페이지 테이블 엔트리(Page Table Entry, PTE)라고 부른다.  
다시 말해 페이지 테이블은 페이지 번호, 프레임 번호로 구성된 페이지 테이블 엔트리의 집합이다.

<br/> 

페이징 기법에서 페이지 테이블 엔트리는 프레임 번호만 가진다.  
페이지 테이블에 페이지 번호가 0부터 순서대로 정리되어 있기 때문에 굳이 페이지 번호를 표시할 필요가 없는 것이다.  
페이지 테이블 엔트리가 페이지 번호, 프레임 번호로 구성된 것은 페이지 번호가 순서대로 저장되지 않은 경우이다. 

<br/> 

### 가상 주소 변환
컴퓨터는 2진법을 사용하므로 한 페이지의 크기는 2의 지수승, 이를테면 2^9(512)B, 2^10(1,024)B, 2^11(2,048)B, 2^12(4,096)B, 2^13(8,192)B 등으로 분할된다.  
유닉스 계열의 운영체제인 VAX는 한 페이지의 크기가 2^9B이다.  
마이크로소프트의 윈도우 NT는 2^12B, 오라클의 솔라리스는 2^13B이다.

<br/> 

페이지의 크기가 다양할 경우 가상 주소를 <P, D>로 변환하는 공식은 다음과 같다.  
> P = 나눗셈(가상 주소 / 한 페이지의 크기)의 몫  
> D = 나눗셈(가상 주소 / 한 페이지의 크기)의나머지
> 

<br/> 

## 페이지 테이블 관리
페이지 테이블 관리가 복잡한 이유는 시스템에 여러 개의 프로세스가 존재하고 프로세스마다 페이지 테이블이 하나씩 있기 때문이다.

<br/> 

아래 그림에서는 프로세스 A, B, C가 하나의 물리 메모리를 사용하고 있다.  
프로세스는 메모리에 올라와야 실행 가능하므로 모든 프로세스의 일부 페이지가 물리 메모리의 프레임에 올라와 있고, 어떤 페이지가 어떤 프레임에 있는지 관리하기 위해 프로세스마다 페이지 테이블을 운영 중이다.  
메모리 관리자는 특정 프로세스가 실행될 때마다 해당 페이지 테이블을 참조하여 가상 주소를 물리 주소로 변환하는 작업을 반복한다.

![image](https://github.com/C0012S/2023CS-Study/assets/66476874/217a142e-9061-4950-8b16-d710a3ab1c49)

<br/> 

페이지 테이블은 메모리 관리자가 자주 사용하는 자료 구조이므로 필요 시 빨리 접근할 수 있어야 한다.  
따라서 페이지 테이블은 물리 메모리 영역 중 운영체제 영역의 일부분에 모아 놓는다.  
시스템 내에서는 여러 개의 프로세스가 존재하고 프로세스마다 하나의 페이지 테이블이 있기 때문에 전체 페이지 테이블의 크기는 프로세스의 수에 비례해서 커진다.  
한 번에 실행하는 프로세스의 수가 많으면 페이지 테이블의 크기가 같이 커지고, 이에 따라 프로세스가 실제로 사용할 수 있는 메모리 영역이 줄어든다.  

<br/> 

페이지 테이블 관리의 가장 큰 문제는 페이지 테이블의 크기가 작지 않다.
따라서 페이지 테이블의 크기를 적정하게 유지하는 것은 페이지 테이블 관리의 핵심이다.

<br/> 

아래 그림은 물리 메모리 내 페이지 테이블의 구조를 나타낸 것이다.

![image](https://github.com/C0012S/2023CS-Study/assets/66476874/73b5ce2b-c195-481a-8d16-28557bac76e8)


<br/> 

페이지 테이블 영역에 프로세스별로 페이지 테이블이 배열되어 있는데 프로세스 A의 페이지 테이블은 상단에, 프로세스 B의 페이지 테이블은 하단에 있다.  
페이지 테이블의 수가 늘어나거나 페이지 테이블의 크기가 늘어나면 운영체제 영역이 늘어나 그만큼 사용자 영역이 줄어든다.  
물리 메모리의 크기가 작을 때는 프로세스만 스왑 영역으로 옮겨지는 것이 아니라 페이지 테이블의 일부도 스왑 영역으로 옮겨진다. 

<br/> 

위의 그림에서 페이지 테이블에 빠르게 접근하기 위해 레지스터가 존재한다.  
각 프로세스가 메모리에 접근하려고 할 때 메모리 관리자는 페이지 테이블의 위치를 재빨리 파악할 필요가 있다.  
그래서 각 페이지 테이블의 시작 주소를 페이지 테이블 기준 레지스터(Page Table Base Register, PTBR)에 보관한다.  
페이지 테이블 기준 레지스터는 각 프로세스의 프로세스 제어 블록에 저장되는 데이터로 물리 메모리 내에 페이지 테이블의 시작 주소를 가지고 있다.

<br/> 

## 페이지 테이블 매핑 방식
시스템 내에는 여러 개의 프로세스가 존재하고, 각 프로세스는 하나의 페이지 테이블을 가지며 페이지 테이블은 운영체제 영역에 있다.  
따라서 페이지 테이블의 크기가 너무 커지면 프로세스가 실제로 사용할 수 있는 메모리 영역이 줄어든다.  
사용할 수 있는 물리 메모리 영역이 적을 경우, 프로세스만 스왑 영역으로 옮겨지는 것이 아니라 페이지 테이블의 일부도 스왑 영역으로 옮겨진다.  
따라서 페이지 테이블 전체를 메모리에서 관리하느냐, 일부를 스왑 영역에서 관리하느냐에 따라 가상 주소를 물리 주소로 변환하는 방법이 달라진다. 

<br/> 

페이지 테이블이 위치한 곳에 따른 페이지 테이블 매핑 방식에는 직접 매핑, 연관 매핑, 집합-연관 매핑, 역매핑이 있다.

<br/> 

### 직접 매핑(Direct Mapping)
직접 매핑은 페이지 테이블 전체가 물리 메모리의 운영체제 영역에 존재하는 방식이다.  
별다른 부가 작업 없이 바로 주소 변환이 가능하기 때문에 직접 매핑이라고 부른다.

<br/> 

물리 메모리가 충분할 때 사용할 수 있으며 모든 페이지를 물리 메모리에 가지고 있기 때문에 주소 변환 속도가 빠르다.

<br/> 

직접 매핑 방식의 구조는 아래 그림과 같다. 

![image](https://github.com/C0012S/2023CS-Study/assets/66476874/01060e9f-b0e2-4972-888b-bf60cd250193)

직접 매핑에서는 페이지 테이블 전체가 물리 메모리에 저장되기 때문에 가상 주소 VA = <P, D>를 물리 주소 PA = <F, D>로 변환하려면 페이지 테이블의 P 번째 위치(PTE P)에서 원하는 프레임 값을 얻을 수 있다.  
페이지 테이블의 시작 주소는 페이지 테이블 기준 레지스터(PTBR)가 가지고 있으므로 물리 메모리상 페이지 테이블의 P 번째 주소가 시작 주소(PTBR)로부터 P 번째 위치에 존재한다.

<br/> 

### 연관 매핑(Associative Mapping)
연관 매핑은 페이지 테이블 전체를 스왑 영역에서 관리하는 방식이다.  
물리 메모리의 여유 공간이 작을 때 사용하는 방식으로 모든 페이지 테이블을 저장 장치의 스왑 영역에 저장하고 그중 일부만 물리 메모리에 가지고 있다.  
연관 매핑은 페이지 테이블의 일부만 무작위로 가져온다.  
일부 내용만 무작위로 배치하기 때문에 페이지 번호와 프레임 번호 둘 다 표시한다.  
따라서 페이지 테이블의 열은 직접 매핑이 1 개, 연관 매핑이 2 개이다.

<br/> 

주소 변환 시 직접 매핑은 원하는 프레임 번호를 한 번에 바로 얻을 수 있지만, 연관 매핑은 물리 메모리 내의 페이지 테이블을 다 검색해야 한다.  
만약 이렇게 했는데도 원하는 프레임 번호를 얻지 못하면 스왑 영역에 있는 페이지 테이블을 검색한다.  
직접 매핑의 경우 어떤 페이지가 어떤 프레임에 있다는 것을 바로 알 수 있지만, 연관 매핑의 경우 위에서부터 검색해야만 찾을 수 있다.  
또한 검색 실패 시 스왑 영역에서 다시 찾아야 하므로 시간을 낭비하게 된다.

<br/> 

연관 매핑은 전체 페이지 테이블을 스왑 영역에 두고 페이지 테이블의 일부를 물리 메모리에 가져오는 방식이므로 물리 메모리는 일부 페이지만 무작위로 저장되어 있고, 그 일부분의 테이블을 변환 색인 버퍼(Translation Look-aside Buffer, TLB) 또는 연관 레지스터(Associate Register)라고 부른다.  
변환 색인 버퍼는 페이지 번호와 프레임 번호로 구성된 작은 크기의 테이블이다.

<br/> 

연관 매핑 방식의 구조는 다음 그림과 같다.

![Untitled](https://shacoding.com/wp-content/uploads/2022/06/image-37.png)

<br/> 

연관 매핑 방식에서 물리 메모리에 일부 테이블만 가지고 있기 때문에 작동 방식도 캐시 시스템과 유사하다.  
> 캐시 시스템에서 원하는 데이터가 캐시에 있는 경우는 캐시 히트, 없는 경우 캐시 미스라고 한다.
> 

연관 매핑에서는 메모리에 접근하기 위해 먼저 변환 색인 버퍼를 찾아본다.  
원하는 페이지 번호가 변환 색인 버퍼에 있는 경우는 TLB 히트(TLB Miss)라고 하며 스왑 영역에 저장된 직접 매핑 테이블을 사용하여 프레임 번호로 변환한다.

<br/> 

연관 매핑 방식은 전체 페이지 테이블을 물리 메모리에 보관하지 않아 메모리를 절약할 수 있다는 것이 장점이다.  
그러나 TLB 미스가 빈번하게 발생할 경우 시스템의 성능이 떨어지는 단점도 있다.  
또한 변환 색인 버퍼는 페이지 테이블의 일부를 무작위로 가지고 있기 때문에 모든 변환 색인 버퍼를 검색한 후에야 원하는 페이지가 메모리에 없다는 것을 알 수 있다.  
즉, TLB 미스를 알게 되는 시점이 변환 색인 버퍼를 모두 검색하고 난 후이다.  
따라서 TLB 미스가 발생하면 주소 변환이 느려진다.

<br/> 

### 집합-연관 매핑(Set-Associative Mapping)
집합-연관 매핑은 연관 매핑의 모든 변환 색인 버퍼를 검색한 후에야 TLB 미스가 있다는 사실을 알게 됨으로써 전체 시스템의 성능이 떨어지는 단점을 개선한 방식이다.  
모든 페이지 테이블을 스왑 영역에서 관리하고 일부만 메모리로 가져온다는 것은 연관 매핑과 동일하다.  
다만 연관 매핑에서는 물리 메모리에 있는 데이터가 무작위로 올라오기 때문에 원하는 프레임 번호를 얻기 위해 모든 테이블을 검색해야 하는 문제가 있었다.  
그러나 집합-연관 매핑에서는 페이지 테이블을 일정한 집합으로 자르고, 자른 덩어리 단위로 물리 메모리에 가져온다.

<br/> 

새로 생성한 집합 테이블(Set Table)에는 일정하게 자른 페이지 테이블이 물리 메모리에 있는지, 스왑 영역에 있는지에 대한 위치 정보를 표시한다.  
I(Invalid)로 표시된 것은 스왑 영역에 있다는 의미이고, 숫자는 물리 메모리의 해당 숫자의 번지에 있다는 의미이다.  
연관 매핑과 비교했을 때, 이 방식은 집합 테이블을 통해 원하는 페이지 테이블 엔트리가 스왑 영역에 있는지, 물리 메모리에 있는지 간단히 파악할 수 있다.  
그러므로 연관 매핑에서처럼 물리 메모리의 모든 페이지 테이블을 검사할 필요가 없어 주소 변환 시간이 단축된다.

<br/> 

일반적으로 컴퓨터를 사용할 때 파일이 많으면 디렉터리를 사용하여 일정한 묶음으로 모아 놓는다.  
디렉터리 매핑(Directory Mapping)이라고도 하는 집합-연관 매핑은 관련 있는 테이블을 덩어리로 모아 놓은 형태이다.

<br/> 

집합-연관 매핑 방식에서는 페이지 테이블을 같은 크기의 여러 묶음으로 나누고, 각 묶음의 시작 주소를 가진 디렉터리 테이블을 새로 만들어 관리한다.  
전체 페이지 테이블은 연관 매핑과 마찬가지로 스왑 영역에 있으며 일부 테이블은 묶음 단위로 메모리로 옮긴다.  
따라서 이 방식에서는 해당 묶음이 현재 메모리에 있는지, 스왑 영역에 있는지를 표시하는 디렉터리 테이블을 새로 만든다.  
디렉터리 테이블을 살펴보면 원하는 테이블 묶음이 어디에 있는지 알 수 있으므로 전체 테이블을 찾아보지 않아도 TLB 미스를 바로 알 수 있다.

<br/> 

- 페이지 테이블이 일정 크기의 묶음으로 나뉘기 때문에 가상 주소를 VA = <P, D>가 아니라 VA = <P1, P2, D>로 바꾸어 표시한다.
    - P1은 디렉터리 테이블의 위치 정보
    - P2는 묶음 내에서의 위치 정보
    - 집합-연관 매핑 방식에서는 직접 매핑 방식처럼 한 번에 물리 주소로 변환되는 것이 아니라 두 단계를 거쳐 물리 주소로 변환된다.

<br/> 

페이지 테이블을 10 개씩 한 묶음으로 나누었다고 가정한다.  
0~9 번 테이블은 0 번 디렉터리에, 10~19 번 테이블은 1 번 디렉터리에 속한다.  
이 경우 가상 주소 32 번지는 직접 매핑에서는 <3, 2>로 변환되지만, 집합-연관 매핑에서는 <0, 3, 2>로 변환된다.  
같은 방법으로 가상 주소 127 번지는 직접 매핑에서는 <12, 7>로 변환되지만, 집합-연관 매핑에서는 <1, 2, 7>로 변환된다.

<br/> 

집합-연관 매핑 방식은 페이지 주소를 세분화한다.  
예를 들어 페이지 번호 3은 0과 3으로, 12는 1과 2로, 178은 17과 8로 나뉜다. 집합-연관 매핑의 가상 주소 VA = <P1, P2, D>에서 P1은 디렉터리 테이블 번호를, P2는 묶음 페이지 테이블 번호를 가리킨다. 여기서 P1은 P2 테이블 덩어리가 메모리 영역에 있는지, 스왑 영역에 있는지에 대한 위치 정보를 나타낸다.  
이러한 특징 때문에 집합-연관 매핑을 멀티페이지 매핑(Multi-Page Mapping)이라고도 일컫는다.

<br/> 

집합-연관 매핑 방식의 구조는 아래 그림과 같다.

![image](https://github.com/C0012S/2023CS-Study/assets/66476874/b467569b-e869-4b38-8cf9-7d2d0da176fd)

- 직접 매핑 방식과 마찬가지로 디렉터리 페이지 테이블의 주소는 페이지 테이블 기준 레지스터(PTBR)가 가지고 있다.
- 프로세스가 특정 주소를 요구하면 VA = <P1, P2, D>로 변환되고, P1을 이용하여 디렉터리 테이블에서 주소를 찾는다.
- 만약 I(Invalid)라고 표시되어 있으면 TLB 미스가 발생한 것이다.
- 반대로 원하는 테이블이 물리 메모리에 있으면 묶음 테이블의 시작 주소가 명시되어 있다.

<br/> 

집합-연관 매핑은 직접 매핑과 연관 매핑의 장점을 합한 방식으로 크기가 큰 페이지 테이블을 같은 크기의 묶음으로 나누어 관리함으로써 효율적이다.  
연관 매핑의 경우 변환 색인 버퍼에 여러 테이블이 섞여 있기 때문에 주소 변환을 위해 변환 색인 버퍼의 모든 테이블을 검색해야 하지만, 집합-연관 매핑에서는 디렉터리 테이블을 이용하여 묶음 테이블의 위치를 바로 확인할 수 있다.  
연관 매핑은 TLB 미스가 발생할 경우 변환 색인 버퍼 전체를 검색하는 데 시간을 낭비하지만 집합-연관 매핑은 이러한 낭비가 발생하지 않는다.  
집합-연관 매핑은 직접 매핑과 달리 일부 페이지 테이블만 메모리에서 관리하여 물리 메모리를 낭비하지 않는다.

<br/> 

### 역매핑(Invert Mapping)
역매핑은 앞의 세가지 매핑과 반대로 페이지 테이블을 구성하는 방식이다.   
직접 매핑, 연관 매핑, 집합-연관 매핑에서는 페이지 번호를 기준으로 테이블을 구성하지만, 역매핑에서는 물리 메모리의 프레임 번호를 기준으로 테이블을 구성한다.  
다시 말해 물리 메모리의 프레임에 어떤 프로세스의 어떤 페이지가 올라와 있는지를 표시한다.  

<br/> 

가상 주소의 페이지를 기준으로 프레임 번호를 매핑하는 방식은 프로세스마다 페이지 테이블이 필요하고, 그 크기도 작지 않기 때문에 물리 메모리 공간을 낭비하는 것이 문제이다.  
역매핑은 이와 달리 물리 메모리의 프레임 번호를 기준으로 테이블을 작성한다. 즉, 물리 메모리가 어떤 프로세스의 어떤 페이지를 가지고 있는지를 테이블 형태로 구성한다.

<br/> 

역매핑의 가장 큰 특징은 프로세스의 수와 상관없이 테이블이 하나만 존재한다는 것이다.  
다른 방식에서는 프로세스마다 페이지 테이블을 만들지만, 역매핑에서는 물리 메모리를 기준으로 프레임 테이블을 만들기 때문에 전체 시스템에서 테이블의 수가 단 1 개이다.  
따라서 테이블의 크기가 매우 작다는 것이 장점이다.

<br/> 

역매핑은 테이블의 크기가 작지만, 프로세스가 가상 메모리에 접근할 때 프로세스 아이디와 페이지 번호를 모두 찾아야 하는 단점이 있다.  
모든 페이지를 검색한 후에야 해당 페이지가 스왑 영역에 있다는 것을 알게 되므로 속도가 아주 느리다.

<br/> 

역매핑 방식의 구조는 아래 그림과 같다.

![image](https://github.com/C0012S/2023CS-Study/assets/66476874/b9750879-ca3b-4955-939c-62f38a059f85)

역매핑 방식에서는 테이블이 <프레임 번호, 프로세스 아이디, 페이지 번호>로 구성되고, 페이지 테이블의 행 수는 실제 프레임의 수와 같다. 그러므로 프로세스의 수와 상관없이 항상 일정 크기의 페이지 테이블을 유지하여 테이블의 크기가 매우 작다.

<br/> 

![Untitled](https://shacoding.com/wp-content/uploads/2022/06/image-39.png)

<br/> 

역매핑 방식에서 주소 변환 시 메모리 관리자는 주소 변환을 해야 하는 프로세스의 아이디와 페이지 번호가 물리 메모리에 있는지 역매핑 테이블에서 검색한다.  
현재 테이블에 원하는 데이터가 없으면 스왑 영역에서 가져온다.  
역매핑은 연관 매핑과 마찬가지로 페이지 테이블을 다 검사한 후에야 저장 장치에 접근하기 때문에 검색 시간을 낭비하는 단점이 있다.

<br/> 

직접 매핑, 연관 매핑, 집합-연관 매핑은 캐시 메모리 관리에도 사용되는 방식이다.  
캐시는 메모리의 일부를 가져오는 기법이므로 전체 페이지 테이블을 메인 메모리로 바꾸어 생각하면 된다.

<br/> 
<br/> 

# ✅ 세그먼테이션 기법
세그먼테이션 기법은 가변 분할 방식을 이용한 가상 메모리 관리 기법으로 물리 메모리를 프로세스의 크기에 따라 가변적으로 나누어 사용한다.

<br/> 

## 세그먼테이션 기법의 구현
아래 그림은 세그먼테이션 기법에서 가상 주소가 물리 주소로 변환되는 과정을 보여 준다.  
페이징 기법과 마찬가지로 세그먼테이션 기법도 매핑 테이블을 사용하는데 이를 세그먼테이션 테이블(Segmentation Table) 또는 세그먼테이션 매핑 테이블(Segmentation Mapping Table)이라고 한다.

<br/> 

![image](https://github.com/C0012S/2023CS-Study/assets/66476874/98309418-118a-4a64-9890-673f68e1a357)

<br/> 

위 그림의 세그먼테이션 테이블에는 세그먼트의 크기를 나타내는 limit와 물리 메모리상의 시작 주소를 나타내는 address가 있다.  
페이징 기법에서는 메모리를 같은 크기의 페이지 단위로 분할하기 때문에 매핑 테이블에 크기 정보를 유지할 필요가 없다.  
하지만 세그먼테이션 기법에서는 프로세스의 크기에 따라 메모리를 분할하기 때문에 매핑 테이블에 크기 정보를 포함한다.  
각 세그먼트가 자신에게 주어진 메모리 영역을 넘어가면 안 되기 때문에 세그먼트의 크기 정보에는 크기를 뜻하는 size 대신 제한을 뜻하는 limit를 사용한다.

<br/> 

세그먼테이션 기법에서도 물리 메모리가 부족할 때 스왑 영역을 사용한다.  
위 그림에서 크기가 100B인 프로세스 D(세그먼트 3)가 스왑 영역에 있고, 세그먼테이션 테이블의 address에 I(Invalid)라고 표시되어 있다.

<br/> 

세그먼테이션 기법은 가변 분할 방식을 기본으로 하므로 가변 분할 방식의 장점과 단점을 모두 가지고 있다.  
장점으로는 메모리를 프로세스 단위로 관리하기 때문에 페이지 테이블이 작고 단순하다는 것을 꼽을 수있다.  
단점은 물리 메모리의 외부 단편화로 인해 물리 메모리 관리가 복잡하다는 것이다. 

<br/> 

## 세그먼테이션 기법의 주소 변환
- 세그먼테이션 기법에서는 가상 주소를 VA = <S, D>로 표현한다.
    - S는 세그먼트 번호(Segment Number)
    - D는 세그먼트 시작 지점에서 해당 주소까지의 거리(Distance)를 의미한다.
    - 가상 메모리 시스템에서 사용자에게 보이는 메모리는 항상 0부터 시작하므로 페이징 기법이든 세그먼테이션 기법이든 D는 사용자가 지정한 주소 그 자체이다.

<br/> 

아래 그림은 세그먼테이션 기법에서 가상 주소를 물리 주소로 변환하는 과정을 보여 준다.  
그림에서는 생략되었지만, 프로세스 A는 세그먼트 0, 프로세스 B는 세그먼트 1, 프로세스 C는 세그먼트 2로 분할되어 있다.

<br/> 

![image](https://github.com/C0012S/2023CS-Study/assets/66476874/2b44cfb9-776c-4d5a-b2fa-96f38b3c9f36)

<br/> 

프로세스 A의 32 번지에 접근할 때, 주소 변환 과정은 다음과 같다.  
1. 먼저 가상 주소를 구한다. 
    1. 프로세스 A는 세그먼트 0으로 분할되었으므로 S는 0이고 D는 32이다.
    2. 가상 주소는 VA = <0, 32>이다.
2. 세그먼테이션 테이블에서 세그먼트 0의 시작 주소를 알아낸 후, 시작 주소 120에 거리 32를 더하여 물리 주소152 번지를 구한다.
    1. 이때 메모리 관리자는 거리가 세그먼트의 크기보다 큰지 점검한다.
    2. 만약 크다면(메모리를 벗어나면) 메모리 오류를 출력하고 해당 프로세스를 강제 종료하며 크지 않다면 물리 주소를 구한다.
3. 물리 주소 152 번지에 접근하여 원하는 데이터를 읽거나 쓴다. 

<br/> 

세그먼테이션 테이블의 limit는 메모리를 보호하는 역할을 한다.  
만약 사용자가 280B를 사용하겠다고 선언한 프로세스 A의 크기보다 더 큰 주소에 접근하려고 하면 메모리 관리자는 해당 프로세스를 강제 종료하는데, 이때 발생하는 오류를 트랩(Trap)이라고 한다.  
트랩은 자신의 영역을 벗어나는 주소에 접근하거나 숫자를 0으로 나누는 것과 같이 사용자가 의도치 않게 일으키는 인터럽트를 말한다.  
트랩이 발생하면 운영체제는 사용자에게 세그먼테이션 오류(Segmentation Fault) 메시지를 보낸다.  
> 트랩과 반대로 사용자가 강제로 Ctrl + C 키를 눌러 프로세스를 중지시키는 것과 같이 사용자가 의도한 인터럽트를 시그널(Signal)이라고 한다.  
> 시그널은 외부 인터럽트 중 하나이다.
> 

<br/> 

위 그림의 가상 주소 VA = <S, D>에서 D는 메모리 보호의 의미가 있다.

<br/> 
<br/> 

# ✅ 세그먼테이션-페이징 혼용 기법
페이징 기법과 세그먼테이션 기법은 각각 장단점을 가지고 있다.  
페이징 기법은 물리 메모리를 같은 크기로 나누어 관리하기 때문에 메모리 관리가 수월한 반면 페이지 테이블의 크기가 크다.  
세그먼테이션 기법은 페이지 테이블의 크기를 작게 유지할 수 있으나 물리 메모리의 외부 단편화로 인해 추가적인 관리가 불가피하다.  
세그먼테이션-페이징 혼용 기법은 이 두 기법의 장점만 취한 가상 메모리 관리 기법이다.

<br/> 

## 메모리 접근 권한
- 메모리 접근 권한은 메모리의 특정 번지에 저장된 데이터를 사용할 수 있는 권한으로 읽기(Read), 쓰기(Write), 실행(Execute), 추가(Append) 권한이 있다.
- 이 4 가지 권한은 복합적으로 사용된다.
    - 예를 들면 일반적인 데이터에는 읽기 및 쓰기 권한이 적용되고, 상수나 읽기 전용 파일에는 읽기 권한이 적용된다. 또한 일반적인 코드 영역에는 읽기 및 실행 권한이 적용된다.

<br/> 

이론상으로는 4 가지 메모리 접근 권한을 모두 조합하면 16(2^4) 가지 메모리 제어 방식(Access Control Modes)이 나온다.  
그러나 추가 권한의 경우 해당 데이터의 마지막에 새로운 데이터를 추가하는 것이므로 항상 쓰기 권한이 동반되어야 한다.  
즉, 쓰기 권한 없이 추가 권한을 사용할 수 없다.  
따라서 추가 권한을 쓰기 권한과 같이 취급한다.  
결론적으로 메모리 접근 권한을 모두 조합하면 아래 표와 같이 8 가지 접근 방식이 나온다.  
읽기 권한 없이 쓰기를 하는 경우는 거의 없기 때문에 실제로 모드 2와 3은 쓰이지 않는다.

<br/> 

- 메모리 접근 권한  

| 구분 | 읽기 | 쓰기 | 실행 | 비고 |
| --- | --- | --- | --- | --- |
| 모드 0 | X | X | X | 접근 불가 |
| 모드 1 | X | X | O | 실행만 가능 |
| 모드 2 | X | O | X | 실제로 사용하지 않음 |
| 모드 3 | X | O | O | 실제로 사용하지 않음 |
| 모드 4 | O | X | X | 읽기 전용 |
| 모드 5 | O | X | O | 읽고 실행 가능 |
| 모드 6 | O | O | X | 읽고 쓰기 가능 |
| 모드 7 | O | O | O | 제한 없음 |

<br/> 

아래 그림은 프로세스의 영역별 메모리 접근 권한을 나타낸 것이다.

![image](https://github.com/C0012S/2023CS-Study/assets/66476874/e6a8ff0e-01a8-4f7d-8bc0-02151dab670a)

프로세스는 몸체에 해당하는 코드 영역, 프로세스가 사용하는 데이터를 저장하는 데이터 영역, 프로세스를 실행하는 데 필요한 스택 영역과 프로세스 제어 블록(PCB)으로 구성된다.

<br/> 

코드 영역과 데이터 영역의 접근 권한은 다음과 같다.  
- 코드 영역
    - 자기 자신을 수정하는 프로그램은 없기 때문에 읽기 및 실행 권한을 가진다.
- 데이터 영역
    - 데이터는 크게 읽거나 쓸 수 있는 데이터와 읽기만 가능한 데이터로 나눌 수 있다.
    - 일반적인 변수는 읽거나 쓸 수 있으므로 읽기 및 쓰기 권한을 가지고 상수로 선언한 변수는 읽기 권한만 가진다.

<br/> 

메모리 접근 권한 검사는 가상 주소에서 물리 주소로 주소 변환이 일어날 때마다 시행된다.  
만약 읽기만 가능한 메모리 영역에 쓰기를 하려고 하면 메모리 오류인 트랩이 발생한다.  
페이징 기법이든 세그먼테이션 기법이든 매핑 테이블에 이러한 메모리 접근 권한에 대한 정보를 가지고 있으며 주소 변환이 일어날 때마다 유용한 접근인지 아닌지 검사한다.

<br/> 

## 세그먼테이션-페이징 혼용 기법의 도입
아래 그림은 페이징 기법에서 메모리 접근 권한까지 고려하여 페이지 테이블을 나타낸 것이다.  
페이지마다 접근 권한이 다르기 때문에 페이지 테이블의 모든 행에는 메모리 접근 권한과 관련된 권한 비트(Right Bit)가 추가된다.  
메모리 관리자는 주소 변환이 이루어질 때마다 페이지 테이블의 권한 비트를 이용하여 유용한 접근인지 아닌지 확인한다.

![Untitled](https://shacoding.com/wp-content/uploads/2022/06/image-41.png)

<br/> 

페이지 테이블에 권한 비트가 추가되면 페이지 테이블의 크기가 커진다.  
이는 인접한 페이지의 메모리 접근 권한이 같은 경우가 많은데도 불구하고 페이지마다 권한 비트를 설정하여 메모리를 낭비하는 요소가 된다.  
이러한 문제를 완화하려면 반복되는 권한 비트를 줄여야 한다.

<br/> 

권한 비트 추가에 따라 페이지 테이블의 크기가 커지는 문제는 세그먼테이션 테이블을 이용하여 해결할 수 있다.  
아래 그림은 위 그림에 세그먼테이션 테이블을 추가한 것이다.  
페이지로 분할된 가상 주소 공간에서 서로 관련 있는 영역을 하나의 세그먼트로 묶어 세그먼테이션 테이블로 관리하고, 각 세그먼트를 구성하는 페이지를 해당 페이지 테이블로 관리하는 방식이다.  
각 세그먼테이션 테이블은 자신과 연결된 페이지 테이블의 시작 주소를 가진다.

![Untitled](https://shacoding.com/wp-content/uploads/2022/06/image-42.png)

<br/> 

페이징 기법에 세그먼테이션 테이블을 추가하고, 권한 비트와 같이 중복되는 데이터를 세그먼테이션 테이블로 옮겨 오면 테이블의 크기를 줄일 수 있다.  
이렇게 페이징 기법과 세그먼테이션 기법을 혼합하여 사용하면 순수 페이징 기법과 순수 세그먼테이션 기법의 장점만 취함으로써 메모리를 효율적으로 관리할 수 있다.  
이를 세그먼테이션-페이징 혼용 기법이라고 한다.

<br/> 

세그먼테이션-페이징 혼용 기법을 사용함에 따라 줄어드는 데이터에는 권한 비트만 있는 것이 아니다.  
유닉스 운영체제의 경우 데이터의 소유 권한과 접근 권한이 같이 명시되어 있다.  
어떤 파일이든 소유자가 지닌 권한 외에 자신이 속한 그룹이 지닌 권한, 자신의 그룹에 속하지 않은 다른 사람이 지닌 권한이 명시되어 있다.  
순수 페이징 기법에서는 이러한 특성을 반영하기 위해 모든 페이지 테이블에 새로운 속성 필드를 추가해야 하지만, 세그먼테이션-페이징 혼용 기법의 경우 이러한 정보를 세그먼테이션 테이블에서 관리함으로써 추가하는 데이터의 양을 줄일 수 있다.

<br/> 

## 세그먼테이션-페이징 혼용 기법의 주소 변환
아래 그림은 세그먼테이션-페이징 혼용 기법을 이용한 가상 메모리 시스템의 전체 구조를 보여 준다.

<img width="351" alt="image" src="https://github.com/C0012S/2023CS-Study/assets/66476874/c24a50c3-299a-4cfe-87eb-5e755d5828ec">

- 왼쪽 그림은 사용자 관점에서 본 메모리 구조이고, 오른쪽 그림은 메모리 관리자 관점에서 본 메모리 구조이다.
    - 사용자 입장에서는 세그먼테이션 기법을 사용하고, 메모리 관리자 입장에서는 페이징 기법을 사용한다.
    - 순수 페이징 기법을 사용하면 중복되는 데이터로 페이지 테이블이 커지기 때문에 현대의 메모리 관리는 페이징 기법과 세그먼테이션 기법을 조화롭게 혼합하여 사용하고 있다.

<br/> 

- 세그먼테이션-페이징 혼용 기법에서는 가상 주소를 VA = <S, P, D>로 표현한다.
    - S는 세그먼트 번호
    - P는 페이지 번호
    - D는 페이지의 처음 위치에서 해당 주소까지의 거리를 의미한다.
    - 이는 페이징 기법의 가상 주소 VA = <P, D>에 세그먼트 번호 S가 추가된 것이다.

<br/> 

- 세그먼테이션-페이징 혼용 기법에서 가상 주소를 물리 주소로 변환하는 과정은 다음과 같다.
    1. 사용자가 어떤 주소에 있는 데이터를 요청하면 해당 주소가 몇 번째 세그먼트의 몇 번째 페이지로부터 얼마나 떨어져 있는지 계산하여 가상 주소 VA = <S, P, D>를 구한다.
    2. 세그먼테이션 테이블의 해당 세그먼트 번호로 가서 자신의 영역을 벗어나는 불법 접근이 아닌지, 권한이 없는 페이지에 접근하는 것은 아닌지 등을 확인한다. 
        1. 만약 권한이 없는 페이지에 접근하거나 자신에게 주어진 메모리 영역을 벗어나면 세그먼테이션 오류(트랩)를 발생시켜 프로세스를 강제 종료한다. 
        2. 그렇지 않으면 연결된 페이지 테이블로 간다.
    3. 페이지 테이블에서 해당 페이지가 어느 프레임에 저장되었는지 찾는다. 
        1. 만약 물리 메모리에 프레임이 있다면 메모리에 바로 접근한다.
        2. 없다면 스왑 영역에 가서 해당 페이지를 물리 메모리로 가져온다.
    4. 물리 메모리에 있는 프레임의 처음 위치에서 D만큼 떨어진 곳에 접근하여 데이터를 읽거나 쓴다.

<br/> 

세그먼테이션 테이블에는 해당 페이지 테이블의 시작 주소가 기록되어 있다.  
따라서 특정 가상 주소 접근 시 세그먼테이션 테이블을 통과하면 페이지 테이블을 이용하여 가상 주소가 물리 주소로 변환된다.  
이를 정리하면 사용자가 특정 주소를 요청했을 때, 세그먼테이션 테이블에서 오류가 없는지, 또 접근 권한을 가지고 있는지 확인하고, 이를 통과하면 연결된 페이지 테이블로 가서 원하는 프레임을 찾는다. 만약 원하는 페이지가 물리 메모리에 없으면 스왑 영역에서 해당 페이지를 가져온다.

<br/> 
<br/> 

# 🗂 참고
- [책] 쉽게 배우는 운영체제
- [OS - 가상 메모리 기초 - SHA Computing (shacoding.com)](https://shacoding.com/2022/06/11/os-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B8%B0%EC%B4%88/)
- [[운영체제] 가상 메모리 (velog.io)](https://velog.io/@sunnamgung8/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC)
- [[OS] 페이지 테이블 매핑 방식 (tistory.com)](https://sommda.tistory.com/63)
