# 💡 Race Condition

# ✅ Race Condition이란?
Race Condition이란 두 개 이상의 cocurrent한 프로세스(혹은 스레드)들이 하나의 자원(리소스)에 접근하기 위해 경쟁하는 상태를 말한다.

<br/>

공유 자원에 여러 프로세스가 동시에 접근할 때 자료의 일관성을 해치는 결과가 나타날 수 있다.

<br/>

## Race Condition이 발생하는 경우
- 커널 코드 실행 중에 인터럽트가 발생할 경우    
    : 커널 모드에서 데이터를 로드하여 작업을 하던 도중 인터럽트가 발생하여 같은 데이터를 조작하는 경우에 발생할 수 있다.    
    커널이 가진 전역변수는 모든 프로세스의 공유물이므로 경쟁 상태의 가능성이 있다.    
    커널 모드에서 작업을 수행하는 동안 인터럽트를 disable시켜 인터럽트가 CPU 제어권을 가져가지 못하도록 하여 해결할 수 있다.    
- 프로세스가 시스템 콜(System Call)을 하여 커널 모드로 진입해서 작업을 수행하는 도중에 문맥 교환이 발생할 경우    
    : 프로세스 1이 커널 모드에서 데이터를 조작하던 도중 시간이 초과되어 CPU 제어권이 프로세스 2로 넘어가 같은 데이터를 조작하는 경우를 말한다.    
    프로세스가 커널 모드에서 작업을 하는 경우에는 시간이 초과되더라도 CPU 제어권이 다른 프로세스에게 넘어가지 않도록 한다.    
- 멀티 프로세서에서 공유 메모리 내의 커널 데이터에 접근할 경우    
    : 멀티 프로세스 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우에 발생할 수 있다.    
    커널 내부에 있는 각 공유 데이터에 접근할 때마다 그 데이터에 대해 lock/unlock함으로써 해결할 수 있다.    

<br/>

이밖에도 멀티 스레드 환경에서 두 개 이상의 스레드가 공통의 전역변수에 접근할 경우 등에서 race condition이 발생할 수 있다

<br/>

## Race Condition이 직면하는 문제
### Mutual Exclusion
Race Condition을 막기 위해서는 두 개 이상의 프로세스가 공용 데이터에 동시에 접근을 하는 것을 막아야 한다. 즉, 한 프로세스가 공용 데이터를 사용하고 있으면 그 자원을 사용하지 못하도록 막거나, 다른 프로세스가 그 자원을 사용하지 못하도록 막으면 이 문제를 피할 수 있다. 이것을 상호 배제(Mutual Exclusion)라고 부른다.

<br/>

### Deadlock
그러나 위와 같은 상호 배제를 시행하면 추가적인 제어 문제가 발생한다. 하나는 교착 상태 즉, 여기서 말하는 Deadlock이다. 프로세스가 각자 프로그램을 실행하기 위해 두 자원 모두에 액세스 해야 한다고 가정할 때, 프로세스는 두 자원 모두를 필요로 하므로 필요한 두 리소스를 사용하여 프로그램을 수행할 때까지 이미 소유한 리소스를 해제하지 않는다. 이러한 상황에서 두 프로세스는 교착 상태에 빠지게 되는 문제가 발생할 수 있다.

<br/>

### Starvation
이 제어 문제는 ‘기아 상태’라고도 한다. 이러한 문제는 프로세스들이 더 이상 진행을 하지 못하고 영구적으로 블록되어 있는 상태로, 시스템 자원에 대한 경쟁 도중에 발생할 수 있고 프로세스 간의 통신 과정에도 발생할 수 있는 문제이다. 두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로는 아무것도 완료되지 못하는 상태가 되게 된다.

<br/>

이렇게 Race Condition인 경우에는 스레드의 실행 순서를 잘 조절해주지 않으면 이상한 상태, 비정상적인 상태가 나오게 된다.  
이 문제는 항상 발생하는 것이 아니라 특정한 순서대로 수행되었을 때 발생하는 것이다. 이 문제는 디버깅을 할 때에는 전혀 보이지 않는 문제점이고, 발생 시에 모든 프로세스에 원하는 결과가 발생하는 것을 보장할 수 없으므로 후에 더욱 큰 문제를 야기할 수 있으므로 반드시 피해야 하는 상황이다.  
이러한 문제가 발생하지 않도록, OS는 다른 프로세스의 의도하지 않은 간섭으로부터 각 프로세스의 데이터 및 물리적 자원을 보호해야 하며 여기에 메모리, 파일 및 I/O 장치와 관련된 내용이 포함된다.  
그리고 프로세스에서 수행하는 내용과 프로세스가 생성하는 결과는, 다른 동시 프로세스의 실행 속도와 무관, 즉, 기능과 결과는 서로 독립적이어야 한다.

<br/>
<br/>

# ✅ 임계 영역(Critical Section)
운영체제에서 여러 프로세스가 데이터를 공유하면서 수행될 때 각 프로세스에서 공유 자원에 접근하는 프로그램 코드 부분을 의미한다.

> 경쟁 상태가 발생할 수 있는 코드의 조각들을 임계 구역으로 이해하면 된다. 
스레드 또는 프로세스 간 공유하고 있는 변수가 있는 코드 조각으로 이해해도 된다.
> 

> 임계 구역에서 경쟁 상태가 발생한 것을 임계 구역 문제(Critical Section Problem)라고 부른다.
임계 구역 문제를 해결한다는 것은 경쟁 상태를 해결한다는 것과 같은 말이다.
> 

<br/>

프로세스 간에 공유 자원을 접근하는 데 있어서 문제가 발생하지 않도록 공유 자원의 독점을 보장해줘야 하는 영역이다.  
임계 영역 문제를 해결하기 위해서는 아래의 3 가지 조건을 충족해야 한다.(임계 구역은 아래의 세 가지 요구 조건을 만족시켜야 유효한 알고리즘이 된다.)  
- Mutual Exclusion(상호 배제)    
    : 한 프로세스가 자신의 ciritical section이면 다른 프로세스들은 ciritical section에 진입할 수 없다.    
- Progress(진행)    
    : 아무도 critical section에 있지 않다면, 진입하고자 하는 프로세스를 진입하게 해줘야 한다.    
    즉, ciritical section에 아무도 진입하지 못하면 안되며 다음에 어떤 프로세스가 ciritical section에 진입해야 하는지는 유한한 시간에 결정되어야 한다.    
- Bounded Waiting(유한 대기)    
    : 프로세스가 ciritical section에 진입하기 위해 무한정으로 기다리는 현상(Starvation)이 발생해서는 안 된다.
    
<br/>
<br/>

# ✅ Race Condition 예방 방법
## Semaphore(세마포어)

![https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/cgvF68/btqDyMXcTWu/zhuMLl9YWBrhRkv6xkEm11/img.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/cgvF68/btqDyMXcTWu/zhuMLl9YWBrhRkv6xkEm11/img.png)

<br/>

공유된 자원의 데이터를 여러 프로세스가 접근하는 것을 막는 것이다.  
또한 세마포어는 리소스의 상태를 나타내는 간단한 카운터라고 할 수 있는데, 일반적으로 비교적 긴 시간을 확보하는 리소스에 대해 이용하게 되며, 운영체제의 리소스를 경쟁적으로 사용하는 다중 프로세스에서 행동을 조정하거나 동기화 시키는 기술이다.  
다시 말해서 하나의 스레드만 들어가게 할 수도 있고 여러 개의 스레드가 들어가게 할 수 있다. 이것이 뮤텍스와의 차이이다.

<br/>

## Mutex(뮤텍스)

![https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/KK4GG/btqDyMXcTVK/dMLkVA1QUmN3khbdFuxoF1/img.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/KK4GG/btqDyMXcTVK/dMLkVA1QUmN3khbdFuxoF1/img.png)

<br/>

공유된 자원의 데이터를 여러 스레드가 접근하는 것을 막는 방법이다.  
즉, Critical Section(각 프로세스에서 공유 데이터를 액세스하는 프로그램 코드 부분)을 가진 스레드들의 Running time이 서로 겹치지 않게 각각 단독으로 실행되게 하는 기술이다.  
다중 프로세스들이 공유 리소스에 대한 접근을 조율하기 위해 locking과 unloking을 사용하는데, 다시 말해서 상호 배제를 함으로써 두 스레드가 동시에 사용할 수 없다는 뜻이다.

<br/>
<br/>

# 🗣 면접 예상 질문
## Q1. 경쟁 상태란 무엇이고, 경쟁 상태가 발생하는 경우에 대해 설명해 주세요.
경쟁 상태는 두 개 이상의 프로세스가 공통 자원을 병행적으로(concurrently) 읽거나 쓰는 동작을 할 때, 공용 데이터에 대한 접근이 어떤 순서에 따라 이루어졌는지에 따라 그 실행 결과가 같지 않고 달라지는 상황을 말한다.

<br/>

경쟁 상태는 다음과 같은 상황에 발생한다.  
1. 커널 작업을 수행하는 중에 인터럽트 발생    
    문제점 : 커널 모드에서 데이터를 로드하여 작업을 수행하다가 인터럽트가 발생하여 같은 데이터를 조작하는 경우    
    해결법 : 커널 모드에서 작업을 수행하는 동안, 인터럽트를 disable시켜 CPU 제어권을 가져가지 못하도록 한다.    
2. 프로세스가 'System Call'을 하여 커널 모드로 진입하여 작업을 수행하는 도중 문맥 교환이 발생할 때    
    문제점 : 프로세스1이 커널 모드에서 데이터를 조작하는 도중, 시간이 초과되어 CPU 제어권이 프로세스 2로 넘어가 같은 데이터를 조작하는 경우 (프로세스2가 작업에 반영되지 않음)    
    해결법 : 프로세스가 커널 모드에서 작업을 하는 경우 시간이 초과되어도 CPU 제어권이 다른 프로세스에게 넘어가지 않도록 함    
3. 멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때    
    문제점 : 멀티 프로세서 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우    
    해결법 : 커널 내부에 있는 각 공유 데이터에 접근할 때마다, 그 데이터에 대한 lock/unlock을 하는 방법
    
<br/>
<br/>

## Q2. 경쟁 상태를 방지하기 위한 해결 방법의 충족 조건을 설명해 주세요.
- Mutual Exclusion (상호 배제)    
    : 어떤 프로세스 가 임계 영역을 수행 중이면 다른 모든 프로세스들은 그 임계 영역에 들어가면 안된다.    
- Progress    
    : 아무도 임계 영역에 있지 않은 상태에서 임계 영역에 들어가려는 프로세스가 있으면 들어가게 해 주어야 한다. (livelock 방지)    
- Bounded Waiting    
    : 프로세스가 임계 영역에 들어가려고 요청한 후부터 다른 프로세스들이 임계 영역에 들어가는 횟수에 한계가 있어야 한다 (starvation 방지)
    
<br/>
<br/>

## Q3. 경쟁 상태 해결 방법은 무엇이 있나요?
1. 상호 배제
2. 동기화
    - 세마포어
    - 모니터
    - 락

<br/>
<br/>

## Q4. 뮤텍스와 세마포어에 대해 설명해 주세요.
세마포어와 뮤텍스는 모두 동기화 문제를 해결하기 위한 방법이다.

<br/>

여러 프로세스가 공유 자원에 접근할 때, 한 프로세스가 임계 영역에서 수행 중이라면 다른 프로세스는 자신의 크리티컬 섹션에 들어가지 못하게 해야 한다.

<br/>

**세마포어**에는 P 연산과 V 연산이 있다. P 연산은 자원을 할당하는 연산이고, V 연산은 자원을 해제하는 연산이다. 크리티컬 섹션에 들어가기 전 세마포어를 통해 자원에 접근 가능한지 확인을 하며 동기화 문제를 해결합니다. 공유 자원에 프로세스들이 최대 허용치만큼 접근할 수 있다.

<br/>

**뮤텍스**는 이진 세마포어의 일종으로 자원에 lock을 걸면서 동기화 문제를 해결한다. 상호 배제 개념을 이용하며 크리티컬 섹션을 가진 스레드들이 각각 단독으로 실행되게 하는 기술이다.

<br/>
<br/>

## Q5. 락을 걸지 않고 경쟁 상태를 해결할 수 있는 방법을 설명해 주세요.
- 하드웨어적으로 atomic 연산을 지원하면 해결
- 가시성은 Atomic 자료형과 volatile을 이용해 해결 가능
- Lock을 사용할 때는 syncronized를 통해 해결.
- 자바 내부적으로는 lock없이 지원을 안 해주므로 message queue를 이용해서 해결하는 방안 등으로 구현 가능하다?

<br/>
<br/>

# 🗂 참고
- [[운영체제] Race Condition과 예방할 방법(세마포어, 뮤텍스) (tistory.com)](https://iredays.tistory.com/125)
- [[OS] Race Condition 경쟁상태란? (tistory.com)](https://zangzangs.tistory.com/115)
- [[운영체제] 경쟁 상태 (Race Condition) (velog.io)](https://velog.io/@klloo/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B2%BD%EC%9F%81-%EC%83%81%ED%83%9C-Race-Condition)
- [[ 운영체제 ] 경쟁상태(Race Condition)와 동기화(Synchronization)의 필요성, 임계 구역(Critical Section) (tistory.com)](https://charles098.tistory.com/88)
- [[OS] Process Synchronization 관련 면접 질문 (oopy.io)](https://yoonah-dev.oopy.io/4a985d19-a3a5-4b05-afbf-78c52305f7ee)
- [면접 준비를 해보자 - 운영체제 (velog.io)](https://velog.io/@xoqja055/%EB%A9%B4%EC%A0%91-%EC%A4%80%EB%B9%84%EB%A5%BC-%ED%95%B4%EB%B3%B4%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)
