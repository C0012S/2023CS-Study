# 페이징 & 세그먼테이션

# 메모리 분할 방식

- 메모리를 어떤 크기로 나눌 것인가
    
    ![Untitled](https://velog.velcdn.com/images%2Fchappi%2Fpost%2F0548516e-18b3-4642-ac4b-3f385d8626f3%2F3.png)
    
- **가변 분할 방식**: 프로세스의 크기에 따라 메모리를 나눈다
    - 프로세스의 크기에 맞게 메모리가 분할되므로 메모리의 영역이 각각 다르다
    - 한 프로세스가 연속된 공간에 배치되기 때문에 연속 메모리 할당이라고 한다
- **고정 분할 방식**: 프로세스의 크기와 상관 없이 메모리를 같은 크기로 나눈다
    - 프로세스가 메모리에 올라오면 분산되어 배치되기 때문에 비연속 메모리 할당이라고 한다
    
- 고정 분할 방식이 관리에 더 용이하다

# ✅ 페이징

> 고정 분할 방식을 이용한 가상 메모리 관리 기법
물리 주소 공간을 같은 크기로 나누어 사용
> 

## 페이지와 프레임

- 페이지: 가상 주소의 분할된 각 영역, 번호를 매겨 관리
- 프레임: 물리 메모리의 각 영역
- 페이지와 프레임의 크기는 같기 때문에 페이지는 어떤 프레임에도 배치 될 수 있음
- 어떤 페이지가 어떤 프레임이 있는지에 대한 연결(매핑) 정보는 페이지 테이블에 담겨 있음
- 페이지 테이블의 invalid는 해당 페이지가 스왑 영역에 있다는 의미

## 특징

- 물리주소 공간은 연속적이지 않을 수 있다
- 페이지는 모두 같은 크기를 가진다
- 물리주소 공간을 페이지와 같은 사이즈로 나눈 것들을 프레임이라고 한다
- 페이지 사이즈는 하드웨어에 의해 정해진다
- 페이지의 크기는 일반적으로 2의 제곱수 사용
- 페이지 테이블을 이용해 논리 주소에서 프레임을 가리키는 물리 주소로 매핑
- 외부 단편화는 발생하지 않으나, 내부 단편화는 발생
    - 외부 단편화: 남아있는 총 메모리 공간이 요청한 메모리 공간보다 크지만, 남아있는 공간이 연속적(contiguous)이지 않아 발생하는 현상
    - 내부 단편화: 주기억장치 내 사용자 영역이 실행 프로그램보다 커서 프로그램의 사용 공간을 할당 후 사용되지 않고 남게 되는 현상

## 페이지 테이블

- 논리 주소의 페이지를 물리 주소의 프레임으로 매핑 시켜주는 정보를 담고 있는 테이블

### 특징

- 페이지 테이블은 per-process 데이터 구조이다. 즉, 모든 프로세스가 페이지 테이블을 가지고 있다
- 페이지 테이블은 메인 메모리에 저장
- Page Table Base Register(PTBR)가 페이지 테이블을 가리키고 있다
- Page Table Length Register(PTLR)가 페이지 테이블의 사이즈를 가리키고 있다
- 이러한 레지스터들의 내용은 PCB에 저장되어 있다. 따라서 문맥교환(context switching)이 일어날 때 교체
- 모든 data/instruction 접근은 두 번의 메모리 접근이 필요
    - 페이지 테이블에 접근하는 오버헤드가 존재
    - 한 번은 페이지 테이블 접근, 한 번은 실제 물리 메모리 접근
    - 두번의 메모리를 접근해야 하는 문제는 fast-lookup hardware cache라고 불리는 associative memory 혹은 translation look-aside buffers(TLBs)를 이용해 해결할 수 있다

### 정형화된 주소 변환

- 페이징 기법에서는 가상 주소를 VA = <P, D> 로 표현
    - VA: 가상 주소
    - P: 페이지
    - D: 페이지의 처음 위치에서 해당 주소까지의 거리
- 페이징 기법에서의 주소 변환은 가상 주소 VA = <P, D>를 물리 주소 PA = <F, D>로 변환 하는 것
    - PA: 물리 메모리의 주소
    - F: 프레임
    - D: 프레임의 처음 위치에서 해당 주소 까지의 거리

### 페이징 기법의 주소 변환 과정

- VA = <P, D> → PA = <F, D>
- 페이지 테이블을 사용하여 P는 F로 바뀌고 D는 그대로
    - D가 변하지 않은 이유는 페이지와 프레임의 크기를 똑같이 나누었기 때문

## 다수의 프로세스가 있는 페이징 시스템

- 프로세스마다 페이지 테이블이 존재
    - 프로세스의 수가 많아지면 페이지 테이블의 크기가 커지고, 이에 따라 프로세스가 실제로 사용할 수 있는 메모리 영역이 줄어 든다
- 페이지 테이블 크기를 적정하게 유지하는 것이 페이지 테이블 관리의 핵심

## 물리 메모리 내 페이지 테이블의 구조

- 각 페이지 테이블의 시작 주소는 페이지 테이블 기준 레지스터에 보관
- 물리 메모리가 작으면 프로세스 뿐 아니라 페이지 테이블의 일부도 스왑 영역으로 이동

## 테이블 매핑 방식

### 직접 매핑

- 페이지 테이블 전체가 물리 메모리의 운영체제 영역에 존재하는 방식
- 별다른 부가 작업 없이 바로 주소 변환 가능

### 연관 매핑

- 페이지 테이블 전체를 스왑 영역에서 관리하는 방식
- 물리 메모리의 여유 공간이 작을 때 사용하는 방식
- 모든 페이지 테이블을 저장장치의 스왑 영역에 저장하고 그중 일부만 물리 메모리에 가지고 있다
- 주소 변환 시 직접 매핑은 원하는 프레임 번호를 한 번에 바로 얻을 수 있지만 연관 매핑은 물리 메모리 내의 페이지 테이블을 다 검색해야 한다

### 집합-연관 매핑

- 연관 매핑의 문제를 개선한 방식
- 모든 페이지의 테이블을 스왑 영역에서 관리하고 일부만 물리 메모리로 가져오는 것은 연관 매핑과 동일
- 페이지 테이블을 일정한 집합으로 자르고, 자른 덩어리 단위로 물리 메모리에서 가져온다
- 집합 테이블을 통해 원하는 페이지 테이블 엔트리가 스왑 영역에 있는지, 물리 메모리에 있는지 간단히 파악 가능
- 연관 매핑에서처럼 물리 메모리의 모든 페이지 테이블을 검사할 필요가 없어 주소 변환 시간 단축

### 역매핑

- 앞의 세가지 매핑과 반대로 페이지 테이블 구성
- 물리 메모리의 프레임 번호를 기준으로 테이블 구성
    - 메모리 프레임에 어떤 프로세스의 어떤 페이지가 올라와 있는지 표시
- 프로세스의 수와 상관 없이 테이블이 하나만 존재
- 물리 메모리를 기준으로 프레임 테이블을 만들기 때문에 전체 시스템에서 테이블의 수가 단 1개
- 가상 메모리에 접근할 때 프로세스 아이디와 페이지 번호를 모두 찾아야 하는 단점
- 모든 페이지를 검색한 후에야 해당 페이지가 스왑 영역에 있다는 것을 알게 되므로 속도가 아주 느림

# ✅ 세그먼테이션

> 가변 분할 방식을 사용한 가상 메모리 관리 기법
물리 메모리를 프로세스의 크기에 따라 가변적으로 나누어 사용
> 
- 페이징 기법에서는 메모리를 같은 크기의 페이지로 분할하기 때문에 매핑 테이블에 크기 정보를 유지할 필요가 없음
- 하지만 세그먼테이션 기법에서는 프로세스의 크기에 따라 메모리를 분할하기 때문에 매핑 테이블에 크기 정보를 포함
- 각 세그먼트가 자신에게 주어진 메모리 영역을 넘어가면 안 되기 때문에 세그먼트의 크기 정보에는 크기를 뜻하는 size 대신 limit 사용
- 물리 메모리가 부족할 때 스왑 영역 사용
- 가변 분할 방식의 장단점을 모두 가짐
- 장점: 메모리를 프로세스 단위로 관리하기 때문에 페이지 테이블이 작고 단순
- 단점: 물리 메모리의 외부 단편화로 인해 물리 메모리 관리가 복잡

# 세그먼테이션-페이징 혼용 기법

- 페이징 기법은 물리 메모리를 같은 크기로 나누어 관리하기 때문에 메모리 관리가 수월한 반면 페이지 테이블의 크기가 크다
- 세그먼테이션 기법은 페이지 테이블의 크기를 작게 유지할 수 있으나 물리 메모리의 외부 단편화로 인해 추가적인 관리가 불가피
- 세그먼테이션-페이징 혼용 기법은 이 두 기법의 장점만 취한 가상 메모리 기법

## 도입

- 페이지마다 접근 권한이 다르기 때문에 페이지 테이블의 모든 행에는 메모리 접근 권한과 관련된 권한 비트가 추가
- 메모리 관리자는 주소 변환이 이루어질 때마다 페이지 테이블의 권한 비트를 이용하여 유용한 접근인지 아닌지 확인
- 권한 비트가 추가되면 페이지 테이블의 크기가 커짐
    - 인접한 페이지의 메모리 접근 권한이 같은 경우가 많은데도 불구하고 페이지마다 권한 비트를 설정
    - 메모리 낭비하는 요소
    - 반복되는 권한 비트를 줄여야 한다
- 세그먼테이션 테이블을 이용하여 해결 가능
    - 페이지로 분할된 가상 주소 공간에서 서로 관련 있는 영역을 하나의 세그먼트로 묶어 세그먼테이션 테이블로 관리
    - 각 세그먼트를 구성하는 페이지를 해당 페이지 테이블로 관리하는 방식
- 각 세그먼테이션 테이블은 자신과 연결된 페이지 테이블의 시작 주소를 가짐

# 질문

### **외부 단편화를 해결하는 페이징(Paging) 기법에 대해 설명해보세요.**

A.  우선, 프레임과 페이징에 대해 설명드리겠습니다. **프레임**이란 **RAM(물리메모리) 를 일정한 크기의 블록으로 나눈 것** 을 뜻하고, **페이징**은 **논리메모리 또는 가상메모리를 일정한 크기의 블록으로 나눈 것** 을 뜻합니다.

이렇게 프레임과 페이징에 대해 설명드린 이유는 페이징 기법에 사용되기 때문입니다. **페이징 기법**이란 **사용하지 않는 프레임을 페이지에 옮기고, 필요한 메모리를 페이지 단위로 프레임에 옮기는 기법**입니다.

이렇게 하기 위해선 프레임과 페이징을 연결해야하는데, 이러한 **Page Mapping에 사용하려고 Page Table을 만듭니다.**

이러한 페이징 기법을 사용하게되면 연속적이지 않은 공간도 연속적으로 활용할 수 있기 때문에 위의 **외부 단편화 문제점을 해결**할 수 있습니다. 만약 페이지 단위를 작게 하면 내부 단편화 문제도 해결할 수 있지만, 그만큼 Mapping 과정 또한 늘어나기 때문에 Trade-Off 가 발생할 수 있습니다.

### **내부 단편화를 해결하는 세그멘테이션(Segmentation) 기법에 대해 설명해보세요.**

A.  페이징 기법은 주로 가상 메모리를 물리적으로 일정한 크기의 단위로 분할하였지만, **세그멘테이션 기법**은 **가상 메모리를 서로 크기가 다른 세그멘트(Segment)를 논리적 단위로 분할해 사용하는 기법** 입니다.

페이징 기법과 마찬가지로 세그먼트 테이블이 존재하는데, 이 **세그먼트 테이블에는 세그먼트 번호, 시작주소, 세그먼트 크기**가 들어있습니다.

그래서 CPU가 세그먼트 테이블에게 테이블 번호, 사용할 메모리 크기를 전달하면, 세그먼트 테이블은 메모리로 가서 해당 테이블 번호의 base(시작주소) 와 limit(세그먼트 크기) 를 비교하여 limit보다 메모리 공간이 작으면 **인터럽트**를 발생시켜 해당 프로세스를 강제 종료합니다.

이러한 세그멘테이션 기법보다는 페이징 기법을 대부분 사용하는데요. 그 이유는 세그멘테이션 기법 또한 크기가 다양한 만큼 다양한 공간이 생기기 때문에 그만큼 메모리 낭비가 존재하기 때문입니다.

**참고**

[OS는 할껀데 핵심만 합니다. 13편 가변 분할 메모리와 고정 분할 메모리, 단편화](https://velog.io/@chappi/OS는-할껀데-핵심만-합니다.-13편-가변-분할-메모리와-고정-분할-메모리-단편화)

[[운영체제] 페이징(Paging)이란? 페이지 테이블이란?](https://code-lab1.tistory.com/55)

[페이징 기법](https://mgyo.tistory.com/462)

[세그먼테이션 기법](https://mgyo.tistory.com/465?category=927419)

[[OS - Memory] 2020.11.20. 오늘의 면접 Q&A](https://maivve.tistory.com/274)
