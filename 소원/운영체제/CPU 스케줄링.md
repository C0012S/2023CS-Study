# CPU 스케줄링

> CPU 스케줄링은 언제 어떤 프로세스에 CPU를 할당할지 결정하는 작업
> 
- CPU 이용률을 극대화 하기 위해서는 멀티프로그래밍이 필요하다
- 하지만 만약 CPU core가 하나라면 한 번에 하나의 프로세스만 실행 가능
- 이때 필요한 것이 CPU 스케줄링

## 목적

- **공평성:** 모든 프로세스가 자원을 공평하게 배정받아야 하며, 자원 배정 과정에서 특정 프로세스가 배제되어서는 안된다
- **효율성:** 시스템 자원이 유휴 시간 없이 사용되도록 스케줄링을 하고, 유휴 자원을 사용하려는 프로세스에는 우선권을 주어야 한다
- **안정성**: 우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정함으로써 시스템 자원을 점유하거나 파괴하려는 프로세스로부터 자원을 보호해야 한다
- **확장성**: 프로세스가 증가해도 시스템이 안정적으로 작동하도록 조치해야 한다. 또한 시스템 자원이 늘어나는 경우 이 혜택이 시스템에 반영되게 해야 한다
- **반응 시간 보장**: 응답이 없는 경우 사용자는 시스템이 멈춘 것으로 가정하기 때문에 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 한다
- **무한 연기 방지**: 특정 프로세스의 작업이 무한히 연기되어서는 안된다

## 스케줄링의 단계

![Untitled](https://blog.kakaocdn.net/dn/LWsTP/btqADYNqTLF/cG56Qkczo8H6kDezOQsWiK/img.png)
### 고수준 스케줄링

- 가장 큰 틀에서 이루어지는 CPU 스케줄링
- 장기 스케줄링, 작업 스케줄링이라고도 한다
- 시스템 내의 전체 작업 수를 조절
    - 작업: 운영체제에서 다루는 일의 가장 큰 단위, 1개 또는 여러개의 프로세스로 이루어짐
- 프로세스에 메모리 및 각종 자원을 주는 문제를 스케줄링
- 어떤 작업을 시스템이 받아들일지 또는 거부할지를 결정
    - 일단 작업이 시작되면 시스템 자원을 사용하기 때문에 기존 작업에 영향을 미친다
    - 작업 요청이 오면 스케줄러가 시스템의 상황을 고려하여 작업을 승인할지, 거부할지 결정
    - 승인 스케줄링이라고도 한다
- 고수준 스케줄링에 따라 시스템 내에서 **동시에 실행 가능한 프로세스의 총 개수**가 정해짐
- 전체 시스템의 부하를 고려하여 작업을 시작할지 말지를 결정
    - 이 결정에 따라
- 최근 운영체제에는 보통 고수준 스케줄러가 없다
    - 프로그램을 실행시키면 곧바로 ready 상태에 돌입

### 중간 수준 스케줄링

- 고수준 스케줄링과 저수준 스케줄링 사이에 일어나는 스케줄링
- 중지와 활성화로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하를 막음
- 즉 일부 프로세스를 중지 상태에 옮김으로써 나머지 프로세스가 원만하게 작동하도록 지원
    - 프로세스의 상태 중 보류 상태에 해당
    - 저수준 스케줄링이 원만하게 이루어지도록 완충하는 역할

### 저수준 스케줄링

- 가장 작은 단위의 스케줄링
- 아주 짧은 시간에 일어나기 때문에 단기 스케줄링이라고 부른다
- 실제로 작업이 이루어짐
- CPU 스케줄러 입장에서 저수준 스케줄링은 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정하는 일
- 준비 상태에 있는 프로세스 중 하나를 골라 실행 상태로 보내고, 실행 상태에 있는 프로세스를 대기 상태로 보내며, 대기 상태의 프로세스를 준비 상태로 보내는 것을 예로 들 수 있다
- 단기 스케줄러가 어떤 기준에 다라 프로세스를 선택하고, 어느 정도 자원을 배분할지에 따라 시스템이 큰 영향을 끼친다
- 오늘날의 CPU 스케줄러는 대부분 중간 수준 스케줄링과 저수준 스케줄링으로 구성

# 스케줄링시 고려 사항

## 스케줄링 기법

### 선점형 스케줄링(Preemptive Scheduling)

> 어떤 프로세스가 CPU를 할당 받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링 방식
> 
- 운영체제가 필요하다고 판단하면 실행 상태에 있는 프로세스의 작업을 중단시키고 새로운 작업 시작 가능
- 대표적인 예로 인터럽트 처리
- Timeout 상황, I/O Interrupt, System call 등이 발생한 경우 현재 실행 상태에 있는 프로세스의 CPU를 강제로 회수하고 다른 프로세스에게 CPU를 할당해줄 수 있는 스케줄링 방식
- 문맥 교환과 같은 부가적인 작업으로 인한 오버헤드가 생김
- 그러나 하나의 프로세스가 CPU를 독점할 수 없기 때문에 빠른 응답 시간을 요구하는 대화형 시스템나 시분할 시스템에 적합
- 대부분의 저수준 스케줄러는 선점형 스케줄링 방식을 사용
- 시분할 스케줄러에 사용

**SRT (Shortest Remaining Time)** 

- 현재 실행 중인 프로세스의 남은 시간과 대기 큐에 프로세스의 실행시간이 가장 짧은 프로세스에게 CPU를 할당하는 기법 (비선점 기법인 SJF 알고리즘의 선점 형태로 변경한 기법)
- 단점 : 잦은 선점으로 인한 문맥교환의 부담, starvation 의 위험

**선점 우선순위** 

- 준비상태 큐의 프로세스들 중에서 우선순위가 가장 높은 프로세스에게 먼저 CPU를 할당하는 기법

**RR(Round Robin)**

- 시분할 시스템을 위해 고안된 방법으로, FCFS 알고리즘을 선점 형태로 변형한 기법
- 대기 큐를 사용하여 먼저 대기한 작업이 먼저 CPU를 사용
- 단점 : CPU를 사용할 수 있는 시간(Quantum)동안 CPU를 사용한 후에 다시 대기 큐의 가장되로 배치된다. 할당되는 시간이 클 경우 FCFS 기법과 같아지고, 시간이 작을 경우 문맥교환 및 오버헤드가 자주 발생됨

**MLQ (다단계 큐)**

- 프로세스를 특정 그룹으로 분류할 수 있는 경우 그룹에 따라 각기 다른 준비상태 큐를 사용
- 작업들을 여러 종류의 그룹으로 분할
- 큐들간에 프로세스 이동이 불가능하다. 각 큐는 자신만의 독자적인 스케줄링을 가짐
- 상위 우선 순위의 큐가 Empty 이면 하위 우선순위의 큐의 프로세스가 수행됨

**MLFQ (다단계 피드백 큐)**

- 특정 그룹의 준비상태 큐에 들어간 프로세스가 다른 준비상태 큐로 이동할 수 없는 다단계 큐 기법을 준비상태 큐 사이를 이동할 수 있도록 개선한 기법
- 새로운 프로세스는 높은 우선순위, 프로세스의 실행이 길어질 수록 점점 낮은 우선순위 큐로 이동
- 제일 마지막 단계에서는 RR/FCFS 처리. 우선순위가 높은 단계의 큐일수록 시간 할당량을 작게 설정
- 기아 상태를 예방하는 Aging 방법
- 현대 OS에서 RR방식과 함께 가장 많이 사용되는 스케줄링 기법

**RM (Rate Monotonic, 주기단조) 알고리즘** 

- 수행 주기가 가장 짧은 프로세스에 가장 높은 우선순위를 부여하는 실시간 스케줄링 알고리즘
- 정적 스케줄링방식이며 마감 시간과 주기가 일치
- 장점 : 간단, 사용률이 0.69이하일때 항상 스케줄링 가능
- 단점 : 주기가 긴 태스크들의 우선순위가 낮아서 장시간 대기

**EDF (Earliest Deadline First, 최단 마감시간 우선)알고리즘** 

- 프로세스의 마감시한이 가까울수록 우선순위를 높게 부여하는 선점방식의 동적 스케줄링
- 장점 : 이론적으로 총 이용률이 1이하면 스케줄링 가능
- 단점 : 태스크들의 수행 시간, 마감시간, 주기 등을 정확히 예측하는 것이 현실적으로 어려움

### 비선점형 스케줄링(non-Preemptive Scheduling)

> 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 방식
> 
- 어떤 프로세스가 실행 상태에 들어가 CPU를 사용하면 그 프로세그가 종료되거나 자발적으로 대기 상태에 들어가기 전까지는 계속 실행된다
- 선점형 스케줄링보다 스케줄러의 작업량이 적고 문맥 교환에 의한 낭비도 적음
- 그러나 CPU 사용 시간이 긴 프로세스 때문에 CPU 사용 시간이 짧은 여러 프로세스가 오랫동안 기다리게 되어 전체 시스템의 처리율이 떨어짐
- 과거의 일괄 작업 시스템에서 사용하던 방식

**FCFS (FIFO)**

- 준비상태 큐에 도착한 순서에 따라 CPU를 할당하는 기법
- 평성은 유지되지만 짧은 작업이 긴 작업을, 중요한 작업이 중요하지 않은 작업을 기다리게 됨
- 장점 : 평균 응답시간이 길다. (대화식 시스템에 부적합)
- 단점 : 도착 순서에 따라 공평하다.

**SJF (Shortest Job First)**

- 실행시간이 가장 짧은 프로세스에 먼저 CPU를 할당하는 기법
- 가장 적은 평균 대기 시간을 제공하는 최적 알고리즘
- 장점 : 평균 응답 시간을 최소화 할 수 있다.
- 단점 : 실행시간이 긴 프로세스는 CPU를 할당받지 못하고 무한히 대기하는 현상 발생(starvation)

**HRN (Highest Response ratio)**

- 실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완
- 우선순위 계산 결과 값이 높은 것부터 우선순위가 부여됨
    - 대기 시간이 길수록 계산 결과가 높음
- 우선순위 = (대기시간 + 서비스시간 / 서비스시간) 큰 프로세스일수록 우선순위가 낮으므로 평균 응답시간도 단축
- **기한부**(DeadLine) : 프로세스에게 일정한 시간을 주어 그 시간 안에 프로세스를 완료하도록 하는 기법
- **우선순위**(Priority) : 준비상태 큐에서 기다리는 각 프로세스마다 우선순위를 부여하여 그 중 가장 높은 프로세스에게 먼저 CPU를 할당하는 기법. 정적, 동적 우선순위 방법 존재

## 프로세스 우선순위

- 대부분의 CPU 스케줄러는 우선순위를 사용
    - 우선순위가 있다는 것은 프로세스의 중요도가 다르다는 의미
- 프로세는 크게 **커널 프로세스**와 **일반 프로세스**로 나뉨
    - 커널 프로세스의 우선순위가 일반 프로세스보다 높다
- 우선순위가 높다는 것은 더 빨리 자주 실행된다는 의미
- 일반 프로세스도 우선순위가 서로 다름
    - 일반 프로세스의 우선순위는 사용자가 조절 가능

## CPU 집중 프로세스와 입출력 집중 프로세스

- 프로세스는 생성된 후 준비, 실행, 대기 상태를 거쳐 완료 됨
- 준비 상태는 CPU를 할당 받기 위해 기다리는 상태이므로 실제 작업이 일어나는 것은 실행 상태와 대기 상태
- 프로세스는 CPU를 사용하여 작업을 하는 실행 상태 또는 입출력을 요청하여 완료되기까지 기다리는 대기 상태에 있따
- 이 때 CPU를 할당 받아 실행하는 작업을 **CPU 버스트**, 입출력 작업을 **입출력 버스트** 라고 한다
- **CPU 집중 프로세스**: CPU를 많이 사용하는 프로세스, 즉 CPU 버스트가 많은 프로세스
- **입출력 집중 프로세스**: 입출력을 많이 사용하는 프로세스, 즉 입출력 버스트가 많은 프로세스
- CPU 집중 프로세스와 입출력 집중 프로세스가 같이 있을 대 입출력 집중 프로세스를 먼저 실행상태로 옮기는 것이 효율적
    - 입출력 요구에 의해 대기 상태로 옮겨지기 때문에 다른 프로세스가 CPU를 사용 가능
- 스케줄링시 입출력 집중 프로세스의 우선순위를 CPU 집중 프로세스보다 높이면 시스템의 효율이 향상
- 입출력 집중 프로세스가 CPU 집중 프로세스보다 실행 상태에 먼저 들어가는 경우를 사이클 훔치기(cycle stealing)라고 함

## 전면 프로세스와 후면 프로세스

- **전면 프로세스**: GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓인 프로세스
    - 현재 입력과 출력을 사용하는 프로세스
    - 사용자와 상호작용 가능 → 상호작용 프로세스
- **후면 프로세스**: 사용자와 상호작용이 없는 프로세스
    - 사용자의 입력 없이 작동 → 일괄 작업 프로세스
- 전면 프로세스는 사용자의 요구에 즉각 반응해야 하지만 후면 프로세스는 상호작용이 없음
    - 전면 프로세스의 우선순위가 후면 프로세스보다 높다

## 

커널 프로세스 > 일반 프로세스

전면 프로세스 > 후면 프로세스

대화형 프로세스 > 일괄 처리 프로세스

입출력 집중 프로세스 > CPU 집중 프로세스

# 질문

### **CPU 스케줄링은 언제 발생하는가?**

- 실행상태에서 대기상태로 전환될 때 (예, 입출력 요청) - Non preemptive(비선점)
- 실행상태에서 준비상태로 전환될 때 (예, 인터럽트 발생) - preemptive(선점)
- 대기상태에서 준비상태로 전환될 때(예, 입출력이 종료될 때)
- 종료될 때(Terminated)

### **선점 스케줄링과 비선점 스케줄링의 차이점?**

선점 : CPU를 할당받아 실행 중인 프로세스로부터 CPU를 선점(빼앗는 것)하여 다른 프로세스를 할당 할 수 있는 방식

Ex) RR, SRT, MLQ, MFQ

비선점 : CPU를 할당받은 프로세스는 스스로 CPU를 반납할 때까지 CPU를 독점하여 사용

Ex) FCFS, SJR, HRN

**참고**

[[운영체제] CPU 스케줄링 알고리즘 정리 및 요약 | FCFS, SJF, Round Robin](https://code-lab1.tistory.com/45)

[스케줄링의 목적과 스케줄링 기법 정리](https://sunny-jang.tistory.com/31)

[[운영체제(OS)] CPU 스케줄링 - (1) CPU 스케줄링의 개념](https://kjhoon0330.tistory.com/m/entry/운영체제OS-CPU-스케줄링)

[[운영체제(OS)] 면접 예상 질문과 답변](https://hyonee.tistory.com/95)
