# 가상 메모리의 기초

# 가상 메모리의 개요

- 컴퓨터마다 물리 메모리, 즉 실제 메모리의 크기가 다름
- 가상 메모리는 크기가 다른 물리 메모리에서 일관되게 프로세스를 실행할 수 있는 기술

## 가상 메모리 시스템

### 가상 메모리의 개념

- 현대 메모리 관리의 가장 큰 특징은 물리 메모리의 크기와 프로세스가 올라갈 메모리의 위치를 신경 쓰지 않고 프로그래밍하도록 지원한다는 것
    - **가상 메모리 시스템**
- 프로세스는 운영체제가 어디에 있는지, 물리 메모리의 크기가 어느 정도인지 신경 쓰지 않고 메모리를 마음대로 사용 가능

### 가상 메모리의 크기와 주소

- 가상 메모리 시스템의 모든 프로세스는 물리 메모리와 별개로 자신이 메모리의 어느 위치에 있든지 상관없이 **0번지부터 시작하는 연속된 메모리 공간**을 가짐
- 가상 메모리는 크게 **프로세스가 바라보는** **메모리 영역**과 **메모리 관리자가 바라보는 메모리 영역**으로 나뉨
- 이론적으로 가상 메모리는 무한대의 크기
    - 그러나 실제로 가상 메모리의 최대 크기는 그 컴퓨터 시스템이 가진 물리 메모리의 최대 크기로 한정
- 메모리 관리자는 물리 메모리의 부족한 부분을 **스왑 영역**으로 보충
    - 스왑 영역은 하드 디스크에 존재하지만 메모리 관리자가 관리하는 영역으로서 메모리의 일부이며, 가상 메모리의 구성 요소 중 하나
    - 물리 메모리가 꽉 찼을 때 일부 프로세스를 스왑 영역으로 보내고(스왑 아웃), 몇 개의 프로세스가 작업을 마치면 스왑 영역에 있는 프로세스를 메모리로 가져온다(스왑 인)
- 가상 메모리의 크기: 가상 메모리에서 메모리 관리자가 사용할 수 있는 메모리의 전체 크기는 물리 메모리와 스왑 영역을 합한 크기
- **동적 주소 변환**: 가상 메모리 시스템에서 메모리 관리자가 물리 메모리와 스왑 영역을 합쳐서 프로세스가 사용하는 **가상 주소를 실제 메모리 물리 주소로 변환하는 작업**
    - 동적 주소 변환을 거치면 프로세스가 아무 제약 없이 사용자의 데이터를 물리 메모리에 배치할 수 있음

### 가상 메모리의 메모리 분할 방식

- 가상 메모리 시스템에서는 운영체제를 제외한 나머지 메모리 영역을 일정한 크기로 나누어 일반 프로세스에 할당
- 물리 메모리 분할 방식과 마찬가지로 **가변 분할 방식**과 **고정 분할 방식**으로 나뉨
- **세그먼테이션**: 가변 분할 방식을 이용한 메모리 관리 기법
    - 외부 단편화 등의 문제 때문에 잘 사용되지 않음
- **페이징**: 고정 분할 방식을 이용한 메모리 관리 기법
    - 페이지 관리에 어려움이 있음
- 두 기법의 단점을 보완한 세그먼테이션-페이징 혼용 기법을 주로 사용

## 매핑 테이블의 필요성과 역할

- 메모리 관리시 **매핑 테이블**을 작성하여 관리
- 가상 메모리 시스템에서 가상 주소는 가상 주소는 실제로 물리 주소나 스왑 영역 중 한 곳에 위치
- 메모리 관리자는 **가상 주소와 물리 주소를 일대일 매핑 테이블로 관리**

- 메모리 매핑 테이블을 통해 가상 주소가 물리 메모리의 어느 위치에 있는지 알 수 있다
- 프로세스 A의 어떤 값이 필요할 때 물리 메모리의 세그먼트 0에서 원하는 데이터를 가져옴
- 매핑 테이블은 물리 메모리가 세그먼테이션으로 분할된 경우 뿐만 아니라 페이징으로 분할된 경우에도 똑같은 방식으로 적용됨

# 페이징 기법

## 페이징 기법의 구현

- **고정 분할 방식**을 이요한 가상 메모리 관리 기법
- 물리 주소 공간을 **같은 크기**로 나누어 사용
- 가상 주소의 분할된 각 영역은 **페이지**라고 부름
    - 첫 번째 영억은 페이지 0, 두 번째 영역은 페이지 1과 같이 번호를 매겨 관리
- 물리 메모리의 각 영역은 페이지와 구분하기 위해 **프레임**이라고 부름
    - 프레임도 번호를 매겨 관리
- 페이지와 프레임의 크기는 같음
- 페이지는 어떤 프레임에도 배치될 수 있다
- 어떤 페이지가 어떤 프레임에 있는지에 대한 연결 정보는 **페이지 테이블**에 담겨있음

- 페이지 테이블은 하나의 열로 구성
    - 모든 페이지의 정보를 순서대로 가지고 있음
    - 위 그림의 페이지 테이블은 페이지 0이 프레임 2에 있다는 의미
    - invalid: 해당 페이지가 스왑 영역에 있음

## 페이징 기법의 주소 변환

### 주소 변환 과정

- 프로세스가 30번지의 내용을 읽으려고 할 때의 가상 주소를 물리 주소로 변환하는 과정
    1. 가상 주소 30번지가 어느 페이지에 있는지 찾음
    2. 페이지 테이블의 페이지 3으로 가서 해당 페이지가 프레임 1에 있는 것을 알아냄
    3. 최종적으로 물리 메모리 프레임의 1의 0번째 위치에 접근
        1. 이 주소가 가상 주소 30번지의 물리 주소
- 프로세스가 가상 주소 18번지에 어떤 값을 저장하려고 할 때의 주소 변환 과정
    1. 가상 주소 18번지가 어느 페이지에 있는지 찾음
    2. 페이지 테이블의 페이지 1로 가서 해당 페이지가 프레임 3에 있다는 것을 알아냄
    3. 프로세스가 저장하려는 값을 프레임 3의 8번 위치에 저장

### 정형화된 주소 변환

- 페이징 기법에서 VA=<P, D>로 표현
    - VA: 가상 주소(Virtual Address)
    - P: 페이지(Page)
    - D: 페이지의 처음 위치에서 해당 주소까지의 거리(Distance)
- 위 그림에서 가상 주소 30번지를 VA=<P, D> 방식으로 정의하면 VA=<3, 0>
    - 가상 주소 페이지 3의 0번째 주소
- 페이징 기법에서의 주소 변환은 가상 주소 VA=<P, D>를 물리 주소 PA=<F, D>로 변환하는 것
    - PA: 물리 메모리의 주소를 가리키는 용어
        - 물리 주소 또는 실제 주소
    - F: 프레임
    - D: 프레임의 처음 위치에서 해당 주소까지의 거리
- VA=<P, D>→ PA=<F, D>
    - P는 F로 바꾸고 D는 변경 없이 그대로 쓴다
        - 프레임과 페이지의 크기를 똑같이 나누었기 때문에 D는 변경 없음
- 페이지 테이블을 이용하면 간단하게 가상 주소를 물리 주소로 변환 가능
    - 페이지 테이블: 페이지 번호, 프레임 번호로 구성된 페이지 테이블 엔트리의 집합

### 주소 변환 공식

- P: (가상 주소/한 페이지의 크기)의 몫
- D: (가상 주소/한 페이지의 크기)의 나머지
- 한 페이지의 크기가 512인 시스템에서 가상 주소 2049
    - P: 2049/512의 몫
    - D: 2049/512의 나머지
- 페이지 테이블의 크기는 프로세스의 크기에 비례
    - 물리 주소의 크기와 상관 없이 가상 주소를 많이 사용하면 페이지 테이블의 크기가 늘어나고 적게 사용하면 줄어든다

## 페이지 테이블 관리

- 시스템에는 여러개의 프로세스가 존재하고 프로세스마다 페이지 테이블이 하나씩 존재
    - 전체 페이지 테이블의 크기는 프로세스의 수에 비례해서 커짐
- 페이지 테이블은 메모리 관리자가 자주 사용하는 자료구조이므로 필요시 빨리 접근할 수 있어야함
    - 페이지 테이블은 물리 메모리 영역 중 운영체제 영역의 일부분에 모아놓음
- 페이지 테이블의 크기가 작지 않은 것이 페이지 테이블 관리의 가장 큰 문제
    - 페이지 테이블의 크기를 적정하게 유지하는 것이 페이지 테이블 관리의 핵심
- 페이지 테이블에 빠르게 접근하기 위해 레지스터 존재
    - 각 페이지 테이블 시작 주소를 **페이지 테이블 기준 레지스터**에 보관
    - 이 레지스터는 각 프로세스의 프로세스 제어 블록에 저장되는 데이터로, 물리 메모리 내에 페이지 테이블의 시작 주소를 가지고 있다

## 페이지 테이블 매핑 방식

- 사용할 수 있는 물리 메모리 영역이 적을 경우 프로세스 뿐만 아니라 페이지 테이블의 일부도 스왑 영역으로 옮겨진다
- 페이지 테이블 전체를 메모리에서 관리할지, 일부를 스왑 영역에서 관리할지에 따라 가상 주소를 물리 주소로 변환하는 방법이 달라짐

### 직접 매핑

- 페이지 테이블 전체가 물리 메모리의 운영체제 영역에 존재하는 방식
- 별다른 부가 작업 없이 바로 변환 가능
- 물리 메모리가 충분할 때 사용
- 모든 페이지를 물리 메모리에 갖고 있기 때문에 주소 변환 속도가 빠름
- 가상 주소를 물리 주소로 바꾸는 VA=<P, D>→ PA=<F, D>를 위해서는 페이지 테이블의 P번째 위치에서 원하는 프레임 값을 얻을 수 있다
    - 페이지 테이블의 시작 주소는 페이지 테이블 기준 레지스터가 가지고 있으므로, 물리 메모리상 페이지 테이블의 P번째 주소가 시작 주소로부터 P번째 위치에 존재

### 연관 매핑

- 페이지 테이블 전체를 **스왑 영역**에서 관리
- 메모리의 여유 공간이 작을 때 사용
- 모든 페이지 테이블을 저장장치의 스왑 영역에 저장하고 **그중 일부만 물리 메모리**에 가지고 있음
- 물리 메모리에는 페이지 테이블의 일부만 무작위로 저장
    - 그 일부분의 테이블을 **변환 색인 버퍼** 또는 **연관 레지스터**라고 부름
        - 페이지 번호와 프레임 번호로 구성된 작은 크기의 테이블
- 작동 방식이 캐시 시스템과 유사
    - 메모리에 접근하기 위해 먼저 변환 색인 버퍼를 찾아봄
    - 원하는 페이지 번호가 있는 경우: **TLB 히트**라고 하며 곧바로 물리 주소로 변환
    - 원하는 페이지 번호가 없는 경우: **TLB 미스**라고 하며 스왑 영역에 저장된 직접 매핑 테이블을 사용하여 프레임 번호로 변환
- 페이지 테이블을 물리 메모리에 보관하지 않아 메모리를 절약할 수 있음
- TBL 미스가 빈번하게 발생할 경우 성능이 떨어짐
- 모든 변환 색인 버퍼를 검색한 후에야 원하는 페이지가 메모리에 없다는 것을 알 수 있음
    - 즉 TBL 미스를 알게되는 시점이 변환 색인 버퍼를 모두 검색하고 난 후
    - TBL 미스가 발생하면 주소 변환이 느려짐
- 일부 내용만 무작위로 배치하기 때문에 페이지 번호와 프레임 번호를 둘 다 표시
    - 페이지 테이블의 열은 직접 매핑 1개, 연관 매핑이 2개
- 물리 메모리 내의 페이지 테이블을 다 탐색해야 원하는 프레임 번호 얻을 수 있다
    - 이렇게 해도 얻지 못하면 스왑 영역에 있는 페이지 테이블 검색

### 집합-연관 매핑

- 디렉터리 매핑, 멀티 페이지 매핑이라고도 함
- 연관 매핑의 문제점 개선
    - 모든 페이지 테이블을 스왑 영역에서 관리하고 일부만 물리 메모리로 가져오는 것은 동일
- 관련 있는 테이블을 덩어리로 모아놓은 형태
- 페이지 테이블을 일정한 집합으로 자르고 자른 덩어리 단위로 물리 메모리에 가져옴
- 페이지 테이블을 자르고 이를 관리하는 페이지 테이블을 하나 더 생성
    - 각 묶음의 시작 주소를 가진 디렉터리 테이블을 새로 만들어 관리
    - 새로 생성한 집합 테이블에는 일정하게 자른 페이지 테이블이 물리 메모리에 있는지, 스왑 영역에 있는지에 대한 위치 정보 표시
- 연관 매핑과 비교했을 때 집합 테이블을 통해 원하는 페이지 테이블 엔트리가 스왑 영역에 있는지, 물리 메모리에 있는지 간단히 파악 가능
    - 연관 매핑에서처럼 물리 메모리의 모든 페이지 테이블을 검사할 필요가 없어 주소 변환 시간 단축
- 페이지 테이블이 일정 크기의 묶음으로 나뉘기 때문에 가상 주소를 VA=<P1, P2, D>로 표시
    - P1: 디렉터리 테이블에서의 위치 정보 - 디렉터리 테이블 번호
    - P2: 묶음 내에서의 위치 정보 - 묶음 페이지 테이블 번호
    - 두 단계를 거쳐 물리 주소로 변환
- 디렉터리 페이지 테이블의 시작 주소는 페이지 테이블 기준 레지스터가 가지고 있다
- 만약 P1에서 찾은 주소에 I라고 표되어 있다면 TLB 미스가 발생한 것
- 직접 매핑과 달리 일부 페이지 테이블만 메모리에서 관리하여 물리 메모리를 낭비하지 않는다

### 역매핑

- 앞의 세 가지 매핑과 반대로 페이지 테이블 구성
    - 페이지 테이블 번호가 아닌 물리 메모리의 프레임 번호를 기준으로 테이블 구성
- 물리 메모리의 프레임에 어떤 프로세스의 어떤 페이지가 올라와 있는지 표시
- 테이블이 <프레임 번호, 프로세스 아이디, 페이지 번호>로 구성
- 페이지 테이블 행의 수는 실제 프레임의 수와 같다
    - 프로세스의 수와 상관없이 항상 일정 크기의 페이지 테이블 유지
- 프로세스의 수와 상관 없이 테이블이 하나만 존재
    - 테이블의 크기가 매우 작다는 것이 장점
- 주소 변환시 메모리 관리자는 주소 변환을 해야하는 프로세스의 아이디와 페이지 번호가 물리 메모리에 있는지 역매핑 테이블에서 검색
    - 없으면 스왑 영역에서 가져옴
- 프로세스가 가상 메모리에 접근할 때 프로세스 아이디와 페이지 번호를 모두 찾아야 하는 단점
    - 모든 페이지를 검색한 후에야 해당 페이지가 스왑 영역에 있다는 것을 알게 되므로 매우 느림

# 세그먼테이션 기법

- 가변 분할 방식을 이용한 가상 메모리 관리 기법
- 물리 메모리를 프로세스의 크기에 따라 가변적으로 나누어 사용

## 세그먼테이션 기법의 구현

- 페이징 기법과 마찬가지로 매핑 테이블을 사용
    - 세그먼테이션 테이블(세그먼테이션 매핑 테이블)
- 세그먼테이션 테이블에는 세그먼트의 크기를 나타내는 limit와 물리 메모리상의 시작 주소를 나타내는 address가 있음
    - 프로세스의 크기에 따라 메모리를 분할하기 때문에 매핑 테이블에 크기 정보를 포함
    - 각 세그먼트가 자신에게 주어진 메모리 영역을 넘어가면 안되기 때문에 limit으로 표현
- 물리 메모리가 부족하면 스왑 영역 사용
- 가변 분할 방식을 기본으로 하기 때문에 가변 분할 방식의 장점과 단점 모두 가짐

## 세그먼테이션 기법의 주소 변환

- VA=<S, D>
    - S: 세그먼트 번호
    - D: 세그먼트 시작 지점에서 해당 주소까지의 거리
    
    ![](https://blog.kakaocdn.net/dn/cal5M2/btruwIwMG8w/I2P6K7OwAFyGmwkOlxCfM0/img.jpg)
    
- 프로세스의 32번지에 접근할 때 주소 변환 과정
1. 가상 주소 구하기
    - 프로세스가 세그먼트 0으로 분할 되었다면 VA=<0, 32>
2. 세그먼테이션 테이블에서 세그먼트 0의 시작 주소를 알아낸 후 시작 주소 120에 거리 32를 더하여 물리 주소 152번지를 구한다
    - 이 때 메모리 관리자는 거리가 세그먼트의 크기보다 큰지 점검
    - 만약 크다면 메모리를 벗어난 것이므로 메모리 오류를 출력하고 해당 프로세스를 강제 종료
        - 세그먼테이션 테이블의 limit은 메모리를 보호하는 역할
        - 이 때 발생하는 오류를 **트랩**이라고 함
            - 트랩: 자신의 영역을 벗어나는 주소에 접근하거나 숫자를 0으로 나누는 것과 같이 사용자가 의도치 않게 일으키는 인터럽트
        - 트랩 발생시 운영체제는 사용자에게 세그먼테이션 오류 메시지를 보냄
    - 크지 않다면 물리 주소를 구함
3. 물리 주소 152번지에 접근하여 원하는 데이터를 읽거나 쓴다

# 세그먼테이션-페이징 혼용 기법

- 페이징 기법
    - 장점:  물리 메모리를 같은 크기로 나누어 관리하기 때문에 메모리 관리가 수월
    - 단점: 페이지 테이블의 크기가 크다
- 세그먼테이션 기법
    - 장점: 페이지 테이블의 크기를 작게 유지할 수 있다
    - 단점: 물리 메모리의 외부 단편화로 인해 추가적인 관리 필요
- 이 두 기법의 장점만 취한 것이 세그먼테이션-페이징 혼용 기법

## 메모리 접근 권한

- 메모리의 특정 번지에 **저장된 데이터를 사용할 수 있는 권한**
    - 읽기, 쓰기, 실행, 추가
- 이론상으로는 네 가지 메모리 접근 권한을 모두 조합하면 16가지 메모리 제어 방식이 나옴
- 그러나 **추가 권한**의 경우 해당 데이터의 마지막에 새로운 데이터를 추가하는 것이므로 **항상 쓰기 권한이 동반**되어야 함
- 즉 쓰기 권한 없이 추가 권한을 사용할 수 없어 추가 권한을 쓰기 권한과 같이 취급
- 결론적으로 모두 조합하면 8가지 접근 방식

| 구분 | 읽기 | 쓰기 | 실행 | 비고 |
| --- | --- | --- | --- | --- |
| 모드0 | x | x | x | 접근 불가 |
| 모드1 | x | x | o | 실행만 가능 |
| 모드2 | x | o | x | 실제로 사용하지 않음 |
| 모드3 | x | o | o | 실제로 사용하지 않음 |
| 모드4 | o | x | x | 읽기 전용 |
| 모드5 | o | x | o | 일고 실행 가능 |
| 모드6 | o | o | x | 읽고 쓰기 가능 |
| 모드7 | o | o | o | 제한 없음 |
- 읽기 권한 없이 쓰기를 하는 경우는 거의 없어 모드 2와 3은 쓰이지 않음

- 프로세스 영역별 메모리 접근 권한
    - 코드 영역, 데이터 영역, 스택 영역, 프로세스 제어 블록으로 구성
    - 코드 영역: 읽기 및 실행 권한
    - 데이터 영역
        - 데이터는 읽거나 쓸 수 있는 데이터와 읽기만 가능한 데이터로 나눌 수 있다
        - 일반적인 변수는 읽거나 쓸 수 있으므로 읽기 및 쓰기 권한을 가짐
        - 상수로 선언한 변수는 읽기 권한만 가짐
- 메모리 접근 권한 검사는 가상 주소에서 물리 주소로 주소 변환이 일어날 때마다 시행
- 만약 읽기만 가능한 메모리 영역에 쓰기를 하려고 하면 트랩 발생

## 세그먼테이션-페이징 혼용 기법의 도입

![](https://shacoding.com/wp-content/uploads/2022/06/image-41.png)

- 페이징 기법에서 메모리 접근 권한까지 고려하여 페이지 테이블을 나타낸 것
- 페이지마다 접근 권한이 다르기 때문에 페이지 테이블의 모든 행에는 메모리 접근 권한과 관련된 **권한 비트**가 추가
- 메모리 관리자는 주소 변환이 이루어질 때마다 페이지 테이블의 권한 비트를 이용하여 유용한 접근인지 아닌지 확인
- 페이지 테이블에 권한 비트가 추가되면 페이지 테이블의 크기가 커진다
    - 인접한 페이지의 메모리 접근 권한이 같은 경우가 많은데도 불구하고 페이지마다 권한 비트를 설정하여 메모리를 낭비하는 요소
    - 따라서 반복되는 권한 비트를 줄여야 함
        - 세그먼테이션 테이블을 이용하여 해결 가능

![](https://shacoding.com/wp-content/uploads/2022/06/image-42.png)

- 페이지로 분할된 가상 주소 공간에 서로 관련 있는 영역을 하나의 세그먼트로 묶어 세그먼테이션 테이블로 관리
- 각 세그먼트를 구성하는 페이지를 해당 페이지 테이블로 관리
- 각 세그먼테이션 테이블은 자신과 연결된 페이지 테이블의 시작 주소를 가짐
- 이와 같이 페이징 기법에 세그먼테이션 테이블을 추가하고, 권한 비트와 같이 중복되는 데이터를 세그먼테이션 테이블로 옮겨 오면 테이블의 크기를 줄일 수 있다
- 현재 대부분의 운영체제는 이 방식 사용

## 세그먼테이션-페이징 혼용 기법의 주소 변환

- 사용자 입장에서는 기본적으로 세그먼테이션 기법 사용
- 메모리 관리자 입장에서는 페이징 기법 사용
- 세그먼테이션-페이징 혼용 기법에서는 가상 주소를 VA=<S, P, D>로 표현
    - S: 세그먼트 번호
    - P: 페이지 번호
    - D: 페이지의 처음 위치에서 해당 주소까지의 거리
- 가상 주소를 물리 주소로 변환하는 과정
1. 사용자가 어떤 주소에 있는 데이터를 요청하면 해당 주소가 몇 번째 세그먼트의 몇 번째 페이지로부터 얼마나 떨어져있는지 계산하여 가상주소 VA=<S, P, D> 구함
2. 세그먼테이션 테이블의 해당 세그먼트 번호로 가서 자신의 영역을 벗어나는 불법 접근이 아닌지, 권한이 없는 페이지에 접근하는 것은 아닌지 등을 확인
    - 만약 권한이 없는 페이지에 접근하거나 주어진 메모리 영역을 벗어나면 세그먼테이션 오류(트랩)을 발생시켜 프로세스 강제 종료
    - 그렇지 않으면 연결된 페이지 테이블로 간다
3. 페이지 테이블에서 해당 페이지가 어느 프레임에 저장되었는지 찾는다
    - 만약 물리 메모리에 프레임이 있다면 메모리에 바로 접근
    - 없다면 스왑 영역에 가서 해당 페이지를 물리 메모리로 가져옴
4. 물리 메모리에 있는 프레임의 처음 위치에서 D만큼 떨어진 곳에 접근하여 데이터를 읽거나 쓴다

- 세그먼테이션 테이블에는 해당 페이지 테이블의 시작 주소가 기록
- 따라서 특정 가상 주소 접근 시 세그먼테이션 테이블을 통과하면 페이지 테이블을 이용하여 가상 주소가 물리 주소로 변환
- 정리하면
    - 사용자가 특정 주소를 요청 했을 때 세그먼테이션 테이블에서 오류가 없는지, 또 접근 권한을 가지고 있는지 확인
    - 이를 통과하면 연결된 페이지 테이블로 가서 원하는 프레임을 찾는다
    - 만약 원하는 페이지가 물리 메모리에 없으면 스왑 영역에서 해당 페이지를 가져온다
