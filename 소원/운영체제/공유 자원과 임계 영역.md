# 💡 공유 자원과 임계 영역역

# ✅ 공유 자원

> 여러 프로세스가 공동으로 이용하는 변수, 메모리, ,파일 등을 말
> 
- 누가 언제 읽거나 쓰느냐에 따라 그 결과가 달라질 수 있다
- 2개 이상의 프로세스가 공유자원을 병행적으로 읽거나 쓰는 상황을 **경쟁 조건이 발생**했다라고 한다

## 경쟁 조건

- 2개 이상의 프로세스가 공유 자원을 병행적으로 읽거나 쓰는 상황
- 데이터의 일관성을 유지하기 위해서는 수행되는 프로세스들이 순차적으로 공유자원에 접근해야 한다
- 공유자원의 접근 순서에 따라 실행 결과가 달라진다

# ✅ 임계 영역

> 공유 자원의 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역
> 
- 임계 구역에서는 프로세스들이 동시에 작업하면 안된다
    - 어떤 프로세스가 임계구역에 들어가면 다른 프로세스는 기다려야 하며, 임계구역의 프로세스가 나와야 들어갈 수 있다
- 전역 변수 뿐만 아니라 하드웨어 자원을 사용할 때도 적용되는 개념

## 임계 구역 해결 조건

임계 구역을 해결하는 알고리즘은 아래와 같은 세 가지 조건을 만족해야 한다

### 상호 배제(Mutual Exclusion)

- 한 프로세스가 임계구역에 들어가면 다른 프로세스는 임계 구역에 들어갈 수 없다

### 한정 대기(Bounded Wating)

- 어떤 프로세스도 무한 대기 하지 않아야 한다
- 특정 프로세스가 임계 구역에 진입하지 못하면 안된다

### 진행의 융통성(Progress Flexibility)

- 한 프로세스가 다른 프로세스의 진행을 방해해서는 안된다

## 임계 구역 해결 방법

> 가장 단순한 방법은 잠금(lock)을 이용하는 방법
임계 구역에 들어갈 때 잠금을 걸고, 나올 때 잠금 해제와 동시에 동기화 신호를 보냄
> 

### 피터슨 알고리즘

![Untitled](https://yansigit.github.io/posts/%ea%b3%b5%ec%9c%a0%ec%9e%90%ec%9b%90%ea%b3%bc-%ec%9e%84%ea%b3%84%ea%b5%ac%ec%97%ad/Untitled%208.png)
- 임계 구역의 세 가지 조건 모두 만족
- `turn`: 두 프로세스가 동시에 lock을 설정하여 임계 구역에 못들어 가는 상황에 대비하는 장치
    - 두 프로세스가 동시에 lock을 설정했더라도 `turn`을 사용하여 다른 프로세스에게 양보

**한계**

- 2개의 프로세스만 사용 가능하다
- 프로세스 수가 늘어나면 변수도 늘어나고 전체적인 알고리즘도 복잡해진다
- 바쁜 대기를 사용하여 자원 낭비
    - `바쁜 대기`: A프로세스는 임계영역에서 실행중이고 B는 대기상태일 때 A가 작업이 완료될 때 까지 B 프로세스가 계속 일어났다 깨어나기를 반복하는 상황을 말함

### 데커 알고리즘

![Untitled](https://yansigit.github.io/posts/%ea%b3%b5%ec%9c%a0%ec%9e%90%ec%9b%90%ea%b3%bc-%ec%9e%84%ea%b3%84%ea%b5%ac%ec%97%ad/Untitled%209.png)
- 하드웨어의 도움 없이 임계구역 문제 해결 가능
- 임계 구역의 세가지 조건 모두 만족

**한계**

- 2개의 프로세스만 사용 가능하다
- 프로세스 수가 늘어나면 변수도 늘어나고 전체적인 알고리즘도 복잡해진다
- 바쁜 대기를 사용하여 자원 낭비

## 세마포어 알고리즘

![Untitled](https://yansigit.github.io/posts/%ea%b3%b5%ec%9c%a0%ec%9e%90%ec%9b%90%ea%b3%bc-%ec%9e%84%ea%b3%84%ea%b5%ac%ec%97%ad/Untitled%2010.png)

![Untitled](https://yansigit.github.io/posts/%ea%b3%b5%ec%9c%a0%ec%9e%90%ec%9b%90%ea%b3%bc-%ec%9e%84%ea%b3%84%ea%b5%ac%ec%97%ad/Untitled%2011.png)

- 프로세스가 작업을 마치면 다음 프로세스에 임계구역을 사용하라는 동기화 신호를 보냄
- 앞의 알고리즘과 비교하여 간단하고 사용이 쉬우며, wakeup 신호를 사용하기 때문에 바쁜 대기를 하지 않아도 된다
- P(): 잠금을 수행하는 코드
    - RS>0이면 (사용 가능한 자원이 있으면)  RS를 1만큼 감소 시키고 임계구역 진입
    - RS≤0이면 (사용 가능한 자원이 없으면) RS가 0보다 커질 때까지 block()
- V(): 잠금 해제와 동기화를 같이 수행
    - RS 값을 1 증가 시킴
    - 기다리는 다른 프로세스에게 wake_up() 신호를 보내 임계 구역에 진입해도 좋다는 신호 보냄
- P()와 V()의 내부 코드는 검사와 지정을 사용하여 분리 실행되지 않고 완전히 실행되게 해야 한다
    - P()나 V() 내부 코드가 실행되는 도중 다른 코드가 실행되면 상호 배제와 한정 대기 조건을 보장하지 못하기 때문

**한계**

- 잘못된 사용으로 임계구역이 보호받지 못할 수 있다
    - 사용자가 고의로 세마포어를 사용하지 않거나 사용중에 실수를 한 경우
    - 즉, 직접 변수에 접근하여 조작할 수 있어 위험

### 모니터

> 고급 언어의 설계 구조물로서, 개발자의 코드를 상호배제 하게끔 만든 추상화된 데이터 형태
> 
- 공유자원에 접근하기 위한 키 획득과 자원 사용 후 해제를 모두 처리
- 데이터와 프로시저(메소드, 함수)를 포함하는 객체
    - 모니터 안에서만 접근 가능
- 모니터 경계에서 상호 배제를 엄격히 지켜야 한다
    - 한번에 한 스레드만 모니터 진입 가능
    - 모니터는 상호 배제 보장
- 모니터가 사용되고 있을 때 들어가려는 스레드는 대기 해야 함
- 모니터 안의 데이터는 모니터 내의 프로시저를 통해서만 접근 가능

**작동 원리**

![Untitled](https://yansigit.github.io/posts/%ea%b3%b5%ec%9c%a0%ec%9e%90%ec%9b%90%ea%b3%bc-%ec%9e%84%ea%b3%84%ea%b5%ac%ec%97%ad/Untitled%2016.png)

- 공유자원을 내부적으로 숨기고 공유자원에 접근하기 위한 인터페이스만 제공하여 자원을 보호하고 프로세스간에 동기화를 시킨다
- 임계 구역으로 들어가려는 프로세스는 P() 혹은 V()를 사용하지 않고 모니터에게 작업을 요청
- 모니터는 요청받은 작업을 모니터 큐에 저장하고 순서대로 처리, 결과만 프로세스에 알려줌
- 시스템 호출과 같은 개념
- 사용자 입장에서는 복잡한 코드를 실행하지 않아서 좋고, 시스템 입장에서는 임계 구역을 보호할 수 있다

# 예상 질문

### 1.  임계 영역이란 무엇이며 만족해야 하는 조건은 무엇인가?

- 공유 자원의 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역
- 상호 배제: 하나의 프로세스가 임계 영역에 들어가있다면 다른 프로세스는 들어갈 수 없어야 한다
- 진행: 임계 영역에 들어간 프로세스가 없는 상태에서, 들어가려 하는 프로세스가 여러개라면 어느 것이 들어갈 지 결정해야 한다
- 한정 대기: 다른 프로세스의 기아를 방지하기 위해, , 한 번 임계 구역에 들어간 프로세스는 다음 번 임계 영역에 들어갈 때 제한을 두어야 한다

### 2. 임계 영역을 해결하기 위한 알고리즘

- 피터슨 알고리즘
- 데커 알고리즘
- 세마포어 알고리즘
- 설명은 위에서..

**참고**

[[운영체제] 5.2 공유 자원과 임계구역](https://chosh95.tistory.com/340)

[공유 자원과 임계구역](https://mgyo.tistory.com/382)

[[OS] 공유 자원과 임계구역](https://junsangkwon.tistory.com/50)

[[OS] 공유 자원과 임계구역](https://velog.io/@suyeonme/OS-공유-자원과-임계구역)

[운영체제 - 공유자원과 임계구역](https://yansigit.github.io/blog/운영체제-공유자원과-임계구역/)

[PintOS - Busy Waiting 바쁜대기 - 1](https://itsc.tistory.com/23)
