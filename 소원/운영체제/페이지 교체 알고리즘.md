# 페이지 교체 알고리즘
- 프로세스가 요구한 페이지가 현재 메모리에 없으면 페이지 부재가 발생
- 페이지 부재가 발생하면 스왑 영역에서 페이지를 메모리로 가져오는데, 만약 메모리가 꽉 찼다면 메모리에 있는 페이지를 스왑 영역으로 내보내야 한다
- 이 때 스왑 영역으로 보낼 페이지를 결정하는 알고리즘이 페이지 교체 알고리즘

## 종류

### 무작위 페이지 교체 알고리즘

- 페이지 교체 알고리즘 중 가장 간단하게 구현 가능
- 스왑 영역으로 쫓아낼 대상 페이지를 특별한 로직 없이 무작위로 선정
- 대부분 프로세스의 메모리 접근 패턴을 보면 메모리의 인접한 영역에 저장되는 지역성을 가지는데, 무작위 알고리즘은 이러한 지역성을 전혀 고려하지 않기 때문에 자주 사용하는 페이지가 대상 페이지로 선정되기도 한다
- 알고리즘의 성능이 좋지 않아 거의 사용되지 않음

### FIFO 페이지 교체 알고리즘

- 시간상으로 메모리에 가장 먼저 들어온 페이지를 대상 페이지로 선정하여 스왑 영역으로 쫓아냄
- 큐로 쉽게 구현할 수 있지만 먼저 들어온 페이지를 항상 스왑 영역으로 옮김
- 시간의 지역성을 고려하면 가장 오래된 페이지를 대상 페이지로 선정하는 것이 맞음
- 그러나 메모리 올라온지 오래 되었더라도 자주 사용되는 페이지가 있는데, FIFO 페이지 교체 알고리즘에서는 메모리에 올라온 시간만 고려하기 때문에 자주 사용되는 페이지가 옮겨지기도 한다
    - 성능이 떨어짐
    - 이러한 문제점을 개선한 것이 2차 기회 페이지 교체 알고리즘

### 최적 페이지 교체 알고리즘

- 앞으로 사용하지 않을 페이지를 스왑 영역으로 옮김
- 메모리가 앞으로 사용할 페이지를 미리 살펴보고 페이지 교체 선정 시점부터 사용 시점까지 가장 멀리 있는 페이지를 대상 페이지로 선정
- 미래의 메모리 접근 패턴을 보고 대상 페이지를 결정하기 때문에 성능이 좋음
    - 하지만 미래의 접근 패턴을 안다는 것이 불가능하여 실제로 구현할 수 없다

### LRU 페이지 교체 알고리즘

- 페이지에 접근한 시간을 기준으로 대상 페이지 선정
- 최근 최소 사용 페이지 교체 알고리즘
- 메모리에 올라온 후 가장 오랫동안 사용되지 않은 페이지를 스왑 영역으로 옮긴다
- 시간을 기준으로 구현할 수 있으며 카운터나 참조 비트를 이용하는 방법도 있다

**페이지 접근 시간에 기반한 구현**

- 페이지에 접근한 지 가장 오래된 페이지를 교체
    - 읽기, 쓰기, 실행과 같은 연산이 이루어진 시간을 기준
- FIFO보다 우수하고 최적 페이지 교체 알고리즘보다는 조금 떨어짐

**카운터에 기반한 구현**

- 접근 시간이 아닌 카운터를 사용하여 구현
- 접근 시간을 기록하든 카운트를 하든 두 방법 모두 추가적인 메모리 공간을 필요로 한다
    - 이러한 추가 공간으로 인해 사용자가 사용할 수 있는 공간이 낭비

**참조 비트 시프트 방식**

- 각 페이지에 일정 크기의 참조 비트를 만들어 사용
- 참조 비트의 초깃값은 0이며 페이지 접근할 때마다 1로 바뀐다
- 참조 비트는 주기적으로 오른쪽으로 한 칸씩 이동
- 공간을 낭비하는 단점

### LFU 페이지 교체 알고리즘

- 페이지가 사용된 횟수를 기준으로 대상 페이지 선정
- 최소 빈도 사용 알고리즘
- 현재 프레임에 있는 페이지마다 그동안 사용된 횟수를 세어 가장 적은 페이지를 스왑 영역으로 옮긴다
- FIFO보다 성능이 우수
- 페이지 접근 횟수를 표시하는데 추가 공간이 필요하여 낭비되는 메모리 공간이 많음

### NUR 페이지 교체 알고리즘

- LRU, LFU 페이지 교체 알고리즘과 성능이 거의 비슷하면서도 불필요한 공간 낭비 문제를 해결한 알고리즘
- 최근 미사용 페이지 교체 알고리즘
- 페이지마다 참조 비트와 변경 비트를 가지므로 페이지마다 추가되는 메모리 공간이 2비트 뿐
    - 참조 비트: 페이지에 접근하면 1이 된다
    - 변경 비트: 페이지가 변경되면 1이 된다
- 우선 고려 대상은 참조 비트
    - 참조 비트가 0인 페이지를 먼저 찾고, 없으면 변경 비트가 0인 페이지를 찾는다
    - 만약 같은 비트의 페이지가 여러개라면 무작위로 대상 페이지를 선정
- LRU, LFU, NUR 페이지 교체 알고리즘의 성능은 거의 비슷
- NUR는 다른 알고리즘과 유사한 성능을 낼 뿐만 아니라 쉽게 구현할 수 있다는 장점 때문에 가장 많이 사용

### FIFO 변형 알고리즘

- FIFO의 단점을 개선
- 페이지에 접근할 때마다 순서의 변화를 주어서 성능 향상

**2차 기회 페이지 교체 알고리즘**

- 큐를 사용하지만, 특정 페이지에 접근하여 페이지 부재 없이 성공할 경우에만 해당 페이지를 큐의 맨 뒤로 이동하여 대상 페이지에서 제외
    - 성공한 페이지를 큐의 맨 뒤로 옮김으로써 기회를 한 번 더 준다
- LRU, LFU, NUR 페이지 교체 알고리즘보다 성능이 약간 낮고, FIFO 페이지 교체 알고리즘 보다는 약간 높음
- 큐를 유지하는 비용이 높고, 페이지가 성공하면 큐의 중간에 있는 값을 뒤로 이동하는 작업이 추가 되는 것이 단점

**시계 알고리즘**

- 2차 기회 페이지 교체 알고리즘과 유사하지만 실제 구현은 다름
- 원형 큐 이용
- 스왑 영역으로 옮길 대상 페이지를 가리키는 포인터 사용
    - 이 포인터가 큐의 맨 바닥으로 내려가면 다음번에는 다시 큐의 처음을 가리키게 된다
- 2차 기회 페이지 교체 알고리즘에 비해 각 페이지에 참조 비트가 하나씩 추가
- 참조 비트의 초깃값은 0이며, 메모리에 있는 페이지를 성공적으로 참조하면 0에서 1로 변경
- 시계 알고리즘의 대상 포인터는 메모리가 꽉 찰 경우 스왑 영역으로 쫓겨날 페이지를 가리킨다
- 가리키는 페이지가 스왑 영역으로 쫓겨나면 대상 포인터를 밑으로 이동
    - 이 때 참조비트가 1인 페이지는 건너 뛰고, 메모리의 바닥에 도착하면 원형 큐처럼 다시 메모리의 상단으로 이동
    - 참조 비트가 1인 페이지를 대상 페이지에서 제외하는 이유는 2차 기회 페이지 교체 알고리즘처럼 기회를 한 번 더 주기 위해서
- 대상에서 제외되는 경우는 단 한 번뿐이고, 참조 비트가 1인 페이지를 건너뛸 때는 0으로 바꿔놓는다
    - 한바퀴를 돌아 다시 대상 포인터가 오면 제외하지 않겠다는 의미
- NUR 알고리즘 보다 추가 공간이 적게 들지만, 알고리즘이 복잡하고 계산량이 많다

# 질문

### **페이지 교체 알고리즘에 대해 알려주세요.**

페이지 부재 발생 시 새로운 페이지를 할당하기 위해 현재 할당된 페이지 중 어느 것과 교체할 지를 결정하는 전략

- 종류
    - FIFO : First-In, First-Out. 메모리에 올라온 지 가장 오래된 페이지를 교체
    - 최적 페이지 교체 : Optimal Page Replace. 이론상 최적 알고리즘
    - NRU 페이지 교체 : Not-Recently-Used. 최근 미사용 페이지 교체
    - LRU 페이지 교체 : Least-Recently-Used. 가장 오래 사용되지 않은 페이지 교체
    - LFU 페이지 교체 : Least-Frequently-Used. 참조 횟수가 가장 작은 페이지를 교체
    - MFU 페이지 교체 : Most-Frequently-Used. 참조 횟수가 가장 많은 페이지를 교체

### LRU 페이지 교체 알고리즘은 어떻게 동작하나요?

- LRU 페이지 교체 알고리즘은 가장 최근에 참조되지 않은 페이지를 대체하는 알고리즘입니다. 각 페이지에 접근할 때마다 시간 정보를 업데이트하고, 대체할 페이지를 선택할 때 가장 오래전에 접근된 페이지를 대체합니다.

**참고**

[[Chapter-02] IT 기술면접대비 & 개발자 면접 질문 - 운영체제](https://sisparang.tistory.com/39)
