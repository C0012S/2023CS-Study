# 파일 시스템

## 개요

### 개념

- 컴퓨터 시스템에는 **다양한 종류의 파일**이 있으며, 이러한 파일은 하드 디스크나 CD 같은 **제 2 저장장치에 보관**
- 보관 과정에서 **사용자가 직접 개입하면** 다른 사용자의 파일을 훼손하거나 저장장치 내부를 어지럽혀 **문제를 일으킬 수 있다**
    - 운영체제는 이를 막기 위해 파일 관리자를 두어 저장장치의 전체 관리를 맡김
        
        → **파일 시스템**
        
    
- 파일 관리자는 **파일 테이블**을 사용하여 **파일의 생성, 수정, 삭제** 등을 수행
- 사용자에게 읽기, 쓰기, 실행과 같은 **다양한 접근 방법 제공**
- 사용자가 특정 파일에 접근하려면 파일 관리자로부터 파일에 접근할 수 있는 권한(키)을 획득해야함
    
    → **파일 디스크립터**
    

### 기능

- 파일 시스템은 파일을 생성하고, 사용자가 편리하게 관리할 수 있도록 **디렉터리 구조** 제공
- 여러 종류의 파일을 구분하기 위해 **이름**과 **확장자** 만들어 관리
- **파일 구성**
    - 사용자의 요구에 따라 파일과 디렉터리를 만든다
- **파일 관리**
    - 파일 생성, 수정, 삭제 등의 관리
    - 수시로 조각 모음을 하여 사용자가 파일에 빨리 접근할 수 있도록 한다
    
    <aside>
    📌 조각 모음
    
    - 하드디스크를 처음 사용할 때는 데이터가 앞에서부터 차곡차곡 쌓이지만, 파일을 저장했다 지우기를 하면 중간중간에 빈 공간이 생김
        - 조각화, 단편화
    - 하드 디스크에 조각이 많이 생기면 큰 파일이 여러 조각으로 나뉘어 저장되고, 이를 읽기 위해 하드 디스크의 여러 곳을 돌아다님
        - 성능 저하 발생
        - 따라서 주기적으로 해주어야 함
    </aside>
    
- **접근 권한 관리**
- **무결성 보장**
- **백업과 복구**
- **암호화**

### 블록과 파일 테이블

**블록**

- 저장장치에서 사용하는 가장 작은 단위
- 한 블록에 주소 하나 할당
- 파일 관리자는 여러 섹터를 묶어 하나의 블록으로 만들고, 블록 하나에 주소 하나 배정
    - 하드 디스크의 가장 작은 저장 단위: 섹터
    - 메모리: 바이트 단위로 저장
    - 하드 디스크가 메모리보다 수백 배 이상 크기 때문에 섹터마다 주소를 부여하면 너무 많은 주소가 필요하기 때문

## 파일 분류와 확장자

- 파일: 논리적인 데이터의 집합
- 모든 파일은 0과 1의 비트 패턴으로 이루어짐

- **실행 파일**
    - 운영체제가 메모리로 가져와 **CPU를 이용하여 작업**을 하는 파일
    - 사용자의 요청으로 프로세스가 된 파일
- **데이터 파일**
    - 실행 파일이 작업하는데 **필요한 데이터를 모아놓은** 파일
    - 스스로 프로세스가 될 수 없음
    - 운영체제가 전송하거나 보관만 할 뿐, 특별하게 다루지 않음
    - ex) 워드 프로세서의 문서파일

- 다양한 종류의 파일을 구별하기 위해 파일에는 **헤더**가 달려있음
    - 파일의 이름, 버전, 크기, 만든 날짜, 접근 권한 등의 정보
- 모든 종류의 파일은 각각 고유한 헤더를 가지고 있음
- 모든 파일 이름에는 확장자가 붙음

## 파일 이름과 연결 프로그램

- 대부분의 파일 이름은 `파일 이름.확장자`의 형태로 구성
- 실행 파일 → 프로세스가 생성되어 실행
- 데이터 파일 → 해당 파일을 사용하는 응용 프로그램이 실행
    - 데이터 파일이 필요로 하는 응용 프로그램을 운영체제가 실행
    - 데이터 파일 자체가 실행되는 것은 아님
- 확장자를 바꾼다고 해서 내용이 바뀌지는 않음

## 파일 속성

- 파일 속성은 각 파일 헤더에 기록
- 운영체제는 이러한 파일 헤더를 파일 테이블에서 관리
- 운영체제가 관리하는 파일 헤더 외에 데이터 파일마다 자신에게 필요한 파일 속성을 따로 정의하여 사용하기도 하는데, 이는 파일의 고유 헤더에 기록


- **파일 헤더**
    - 파일 테이블에서 관리
    - 파일의 이름, 종류, 크기, 시간 ,접근 권한 등과 같은 일반적인 내용
    - 파일이 저장장치의 몇 번째 블록에 있는지에 대한 정보
- **고유 헤더**
    - 파일의 버전 번호, 크기, 특수 정보 등 응용 프로그램이 필요로 하는 정보
    - 파일 복구시 유용하게 사용
    - 파일을 휴지통에 버릴 때 파일 테이블에서만 사라질 뿐 실제 데이터는 지워지지 않음
        - 데이터 파일의 고유 헤더는 저장장치에 남아있음
    - 파일 복구 프로그램은 모든 블록을 찾아다니면서 고유 헤더에 있는 정보를 이용하여 파일을 원래 상태로 복원

## 파일 작업의 유형

- **파일 작업(파일 연산)**: 파일을 지우거나 이름을 바꾸는 것과 같이 파일을 변경하는 것

### 파일 자체를 변경하는 작업

- 파일 탐색기에서 이루어지는 작업
- 열기 닫기, 생성, 이동 ,복사, 이름 변경, 나열, 찾기

### 파일 내용을 변경하는 작업

- 프로세스 입장에서 수행
- open(), create() 함수를 이용하여 운영체제로부터 이용 권한 획득
- 작업이 끝나면 close() 함수 사용하여 운영체제에게 알림

## 파일 구조

### 순차 파일 구조

- 일반 파일은 기본적으로 순차 파일 구조
- 파일 내용이 하나의 긴 줄로 늘어선 형태
- 순차 접근
    - ex) 카세트 테이프에서 원하는 곡을 찾기 위해 앞으로 감거나 뒤로 감음
- 운영체제는 파일 이용 허가를 내리면서 파일 디스크립터를 사용자에게 줌
    - 이때 파일 디스크립터는 파일의 맨 앞에 위치
    - read(), write() 명령을 내리면 파일 디스크립터가 전진
    - 작업을 하다가 특정 위치로 파일 디스크립터를 옮겨야 할 때는 lseek() 사용

**장점**

- 모든 데이터가 순서대로 기록되기 때문에 저장 공간에 낭비되는 부분이 없다
- 구조가 단순하여 테이프, 플로피디스크나 메모리를 이용한 저장장치에도 적용 가능
- 순서대로 데이터를 읽거나 저장할 때 매우 빠르게 처리됨

**단점**

- 파일에 새로운 데이터를 삽입하거나 삭제할 때 시간이 많이 걸림
    - 데이터의 변경이 잦은 경우에 적당하지 않음
- 특정 데이터로 이동할 때 직접 접근이 어렵기 때문에 앞에서부터 순서대로 움직여야 함
    - 데이터 검색에 적당하지 않음

### 인덱스 파일 구조

- 순차 파일 구조의 단점을 해결
- 순차 파일 구조에 인덱스 테이블을 추가하여 순차 접근과 직접 접근이 가능
- 인덱스 순차 접근
    - 인덱스를 이용한 접근 방식
    - ex) CD에서 인덱스 파일이 모든 곡의 시작 부분을 가지고 있어 특정 곡에 접근 가능
    - 이렇게 구성된 파일을 ISAM(Index, Sequential Access Method)파일이라고 함
- 순차 접근과 직접 접근 모두 가능
- 현대의 파일 시스템은 인덱스 파일 구조
    - 파일 저장시 순차 파일 구조로 저장
    - 접근시 인덱스 테이블을 보고 원하는 파일에 직접 접근

**장점**

- 인덱스 테이블을 여러개 만들면 다양한 접근이 가능
- 데이터베이스같이 데이터의 빠른 접근이 필요한 시스템에 사용

### 직접 파일 구조

- 저장하려는 데이터의 특정 값에 어떤 관계를 정의하여 물리적인 주소로 바로 변환하는 파일 구조
- 해시 함수를 이용하여 직접 접근이 가능한 파일 구조
- ex) 학번을 10으로 나눈 나머지를 가지고 주소로 변경한 후, 끝자리가 0이면 0번 저장장치에 저장

**장점**

- 해시 함수를 이용하여 변환하기 때문에 데이터 접근이 매우 빠르다
    - 해시함수는 데이터 키를 입력으로 받고, 그에 대응하는 고정된 범위의 출력값(인덱스) 반환
    - 동일한 키 값에 대해 항상 같은 해시 값이 생성되기 떄문에 데이터를 일관되게 저장하고 검색할 수 있다
    - 인덱스를 통해 바로 데이터를 찾을 수 있어 검색 작업의 시간 복잡도가 O(1)이 된다
    - 삽입 및 삭제 또한 인덱스를 사용하여 이루어지기 때문에 O(1)

**단점**

- 해시 함수의 선정이 매우 중요한데, 데이터가 고르게 저장될 수 있는 해시 함수를 찾아야 한다
    - 데이터가 고르게 저장되지 않고 들쑥날쑥하게 저장되어 있다면 빈공간이 생겨 저장장치의 이용 효율이 떨어짐

# 디렉터리의 구조

## 디렉터리의 개념

- 파일을 하나로 모아놓은 곳
- 1개 이상의 자식 디렉터리를 가질 수 있고, 1개 이상의 파일을 가질 수 있다
- 하나의 디렉터리에는 여러 개의 파일과 자식 디렉터리가 존재
- 여러 층으로 구성할 수 있는데, 최상위에 있는 디렉터리를 루트 디렉터리

## 디렉터리 파일

- 디렉터리도 파일
- 헤더 가짐
    - 디렉터리의 이름, 만든 시간, 접근 권한 등의 정보

## 경로

- 파일의 위치를 나타냄
- **절대 경로**: 루트 디렉터리를 기준으로 파일의 위치 표현
- **상대 경로**: 현재 있는 위치를 기준으로 파일의 위치 표현

## 디렉터리 구조

- 다단계 디렉터리 구조(트리 디렉터리 구조)
    - 단계 확장에 제약이 없음
    - 파일과 디렉터리 둘 다 저장 가능

## 마운트

- 파티션
    - 논리적인 디스크 분할
    - 하나 또는 여러 개의 디스크를 파티션으로 나누어 사용 가능
    - 파티션이 사용자에게 노출되면 사용하기 불편함
    - 초기 윈도우의 경우 파티션마다 서로 다른 파일 테이블 사용
        - 파일 시스템마다 최대 디스크 크기가 제한되었기 때문
- 유닉스: 서버용으로 만들어진 운영체제
    - 파일 테이블 크기에 제한이 없음
    - 하나의 파일 테이블로 여러 개의 디스크 혹은 파티션을 통합하여 관리 가능
    - 하나의 파일 테이블에 여러개의 파티션을 붙여서 사용하는 것
        - 이 때 통합하는 명령어가 마운트
- 마운트를 사용하면 파티현이 몇 개라도 하나로 통합 가능

# 디스크 파일 할당

## 연속 할당과 불연속 할당

- 파일 시스템은 전체 디스크 공간을 같은 크기로 나누고 각 공간에 주소를 붙여서 관리
    - **블록**: 같은 크기로 나뉜 공간 하나
- 파일 시스템은 **파일의 이름**과 해당 **파일이 시작하는 블록 주소**를 가진 파일 테이블 관리
- 파일 테이블은 **파티션당 하나씩 존재**하며 각 파티션의 **맨 앞부분**에 위치

### 연속 할당

- 파일을 구성하는 데이터를 디스크 상에 **연속적으로 배열**
- 파일의 시작 블록만 알면 전체 파일을 찾을 수 있음
- 실제로 사용하지는 않음
    - 파일을 저장하거나 삭제하다 보면 빈 공간이 생김
    - 디스크에 남은 공간 중 파일의 크기와 맞는 연속된 공간이 없을 때는 연속 할당이 불가능

### 불연속 할당

- 비어있는 블록에 데이터를 분산하여 저장하고 이에 관한 정보를 파일 시스템이 관리

**연결 할당(체인 할당)**

- 파일에 속한 데이터를 **연결 리스트**로 관리
- **파일 테이블에는 시작 블록에 대한 정보**만 저장
- 나머지 데이터는 시작 블록부터 연결하여 저장
- 파일의 맨 끝에 해당하는 블록에는 링크 대신 널 삽입
- 테이블 형태로 관리
    - ex) 윈도우의 FAT: 파티션 전체 블록에 대한 정보를 가진 테이블
- **단점**
    - 하나의 파티션이 사용할 수 있는 디스크 용량이 테이블의 주소 크기로 제한됨
    - 현재 윈도우 운영체제는 64bit 주소를 지원하는 NTFS 파일 시스템 사용

**인덱스 할당**

- 연결 리스트의 단점을 해결하기 위한 방법
- 테이블의 **블록 포인터**가 데이터의 인덱스를 담고 있는 **인덱스 블록을 연결**
- **인덱스 블록**은 실제 **데이터의 위치에 관한 정보**를 순서대로 보관
- 테이블이 꽉 차서 더 이상 데이터를 연결할 수 없을 때엔 인덱스 블록을 연결하는 **간접 인덱스 블록**을 만들어 테이블 무한히 확장 가능
- ex) 유닉스 운영체제의 I-node
    - 파일 제어 블록: 파일 소유자와 각종 속성을 나타냄
        - 파일에 대한 모든 권한의 정보를 포함하고 있음 →  슈퍼블록이라고도 함
    - 블록 포인터: 데이터가 있는 블록의 위치를 직접 연결하는 포인터
    - 간접 포인터: 파일 크기가 커서 블록 포인터가 다 차면 인덱스 블록을 생성한 후 간접 포인터를 생성하여 인덱스 블록 연결
    - 이중/삼중 간접 포인터: 파일 크기가 커서 인덱스 블록이 더 필요한 경우 사용
    - 파일 크기가 작은 경우 블록을 직접 연결하여 빠르게 접근
    - 파일 크기가 큰 경우 인덱스 블록과 간접 포인터 이용

## 디스크의 빈 공간 관리

- 블록 하나의 크기를 작게 잡으면 많은 양의 블록 포인터가 필요
- 블록 하나의 크기를 크게 잡으면 적은 주소로 많은 양의 데이터를 관리 할 수 있지만 낭비되는 공간이 생김
    - 이렇게 낭비되는 공간을 **내부 단편화**라고 함
- 디스크의 **내부 단편화를 줄이고** **빈 공간을 효율적으로 관리**하기 위해 파일시스템은 빈 블록의 정보만 모아놓은 **빈 공간 리스트** 유지
