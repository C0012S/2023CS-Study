# 물리 메모리 관리

# 메모리 관리의 개요

## 메모리 관리의 복잡성

- 메모리의 구조는 1B 크기로 나뉨
- 나뉜 각 영역은 메모리 주소로 구분
- CPU는 메모리에 있는 내용을 가져오거나 작업 결과를 메모리에 저장하기 위해 **주소 레지스터** 사용
- 오늘날의 시분할 시스템에서는 운영체제를 포함한 모든 응용 프로그램이 메모리에 올라와 실행되기 때문에 관리가 복잡
- **운영체제도 프로그램**이기 때문에 메모리에 올라와야 실행 가능
    - 메모리에는 사용자 프로세스 뿐만 아니라 운영체제 프로세스도 공존
- 부팅: 컴퓨터를 사용할 수 있는 환경을 마련하는 과정
    - 하드디스크에 저장된 운영체제가 메모리에 올라감
    - 부팅이 끝나면 여러 응용 프로그램이 메모리에서 작업 가능
- **메모리 관리 시스템**이 메모리를 관리

## 메모리 관리의 이중성

- 프로세스가 작업하는 도중에 할당된 공간이 부족하면
    - 메모리 관리자는 새로운 공간을 확보하기 위해 옆의 프로세스를 밀어내거나 더 큰 공간으로 해당 프로세스를 옮겨준다
    - 작업을 마치고 난 후 빈 공간이 생기면 다음 작업을 위해 빈 공간을 만든다
        - 이렇게 하기 위해 현재 작업 중인 공간을 옆으로 밀고 작은 공간을 합쳐 나감
    
    → 매번 작업 공간을 키웠다 줄였다 하는 것은 매우 복잡한 일
    

- 메모리 관리의 이중성: 프로세스 입장에서는 메모리를 독차지 하려 하고, 메모리 관리자 입장에서는 되도록 관리를 효율적으로 하고 싶어 하는 것
    - 프로세스 입장에서 작업의 편리함과 관리자 입장에서 편리함이 충돌을 일으키는 것
- 현대의 메모리 관리 시스템은 프로세스와 메모리 관리자의 상충되는 요구 완벽하게 처리

## 소스코드의 번역과 실행

### 컴파일러와 인터프리터의 동작

- 컴파일러와 인터프리터 모두 언어 번역 프로그램
    - 고급 언어로 작성한 소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역하는 프로그램
- **컴파일러:** 소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역한 후 한꺼번에 실행
    - C언어 , 자바 등
- **인터프리터:** 소스코드를 한 행씩 번역하여 실행
    - 자바스크립트, 베이직 등

### 컴파일러의 목적

**오류 발견**

- 오류를 찾기 위해 **심벌 테이블** 사용
    - 변수 선언부에 명시한 각 변수의 이름과 종류를 모아놓은 테이블
    - 선언하지 않은 변수를 사용하지 않았는지
    - 변수에 다른 종류의 데이터를 저장하지 않았는지

**코드 최적화**

- 최적화를 통해 코드가 더욱 간결해져 실행 속도가 빨라짐
- 실행하기 전에 코드를 점검하여 오류를 수정하고 최적화함으로써 작고 빠른 실행 파일을 만든다

### 컴파일러와 인터프리터의 차이

- **컴파일러**를 사용하는 프로그래밍 언어는 **사용할 변수를 먼저 선언**한 후 코드를 작성
    - 변수 선언은 오류를 찾고 코드를 최적화하기 위해 반드시 필요
- **컴파일러**는 실행 전에 소스코드를 점검하여 오류를 수정하고 필요 없는 부분을 정리하여 최적화된 실행 파일을 만든다
    - **컴파일 후 실행**
- **인터프리터**는 **한 줄씩** 위에서부터 아래로 **실행**되기 때문에 같은 일을 반복하는 경우나 필요 없는 변수를 확인할 수 없다
- 따라서 크고 복잡한 프로그램에는 컴파일러, 간단한 프로그램에는 인터프리터 사용

### 컴파일 과정

- 컴파일: 사용자가 작성한 소스코드를 목적 코드로 변환 후 라이브러리를 연결하여 최종 실행 파일을 만들어 실행하는 과정
1. 소스코드 작성 및 컴파일
    - 컴퓨터는 기계어만 인식할 수 있기 때문에 사용자가 작성한 소스코드를 일차로 번역
        - 소스코드를 컴파일하면 **목적 코드**가 생성됨
2. 목적 코드와 라이브러리 연결
    - 라이브러리에 있는 코드를 목적 코드에 삽입하여 최종 실행 파일 만든다
        - 라이브러리: 자주 사용하는 함수를 시스템 내에 미리 만들어 둔 것
            - 프로그래머가 직접 만들기 어렵거나 만드는 데 시간이 많이 걸리는 함수를 파일 형태로 모아 놓은 것
3. 동적 라이브러리를 포함하여 최종 실행
    - 동적 라이브러리: 실행할 때 삽입되는 함수를 가진 라이브러리
    - 과거에는 오류가 발견되거나 새로운 기능이 추가될 때마다 새로운 라이브러리를 가져와 다시 컴파일
    - 동적 라이브러리 방식에서는 함수가 변경되어도 새로 컴파일할 필요 없음
        - 함수가 변경되었을 땐 새로운 라이브러리만 사용하여 실행하면 됨

## 메모리 관리자의 역할

- 메모리 관리자: 메모리 관리 유닛(MMU)이라는 하드웨어

### 가져오기(fetch)

- 프로세스와 데이터를 메모리로 가져오는 작업
- 사용자가 요청하면 프로세스와 데이터를 모두 메모리로 가져온다
- 메모리가 충분하지 않은 경우 데이터의 일부만 가져와 실행하기도 함
- 사용자의 요청이 없더라도 앞으로 필요할 것이라고 예상되는 데이터를 미리 가져오기도 함

### 배치(placement)

- 가져온 프로세스와 데이터를 메모리의 어떤 부분에 올려놓을지 결정하는 작업
- 배치 작업 전에 메모리를 어떤 크기로 자를 것인지가 매우 중요
    - 같은 크기로 자르느냐, 실행되는 프로세스의 크기에 맞게 자르느냐에 따라 메모리 관리의 복잡성이 달라지기 때문
- 나누어진 메모리의 구역에 따라 프로세스와 데이터를 어떤 위치에 놓을지 결정하는 것이 배치 작업

### 재배치(replacement)

- 꽉 차있는 메모리에 새로운 프로세스를 가져오기 위해 오래된 프로세스를 내보내는 작업

### 가져오기 정책

- 프로세스가 필요로 하는 데이터를 언제 메모리로 가져올지 결정하는 정책
- 프로세스가 요청할 때 메모리로 가져오는 것이 일반적인 방법
- 필요하다고 예상되는 데이터를 미리 가져오는 방법도 있음(prefetch)

### 배치 정책

- 가져온 프로세스를 메모리의 어떤 위치에 올려놓을지 결정하는 정책
- **페이징**: 메모리를 같은 크기로 자르는 것
- **********************************세그먼테이션:********************************** 프로세스의 크기에 맞게 자르는 것
- 페이징과 세그먼테이션의 장단점을 파악하여 메모리를 효율적으로 관리할 수 있도록 정책을 만든다
- 한정된 메모리를 효율적으로 사용하기 위한 것으로, 시스템의 효율을 좌우하는 매우 중요한 기준

### 재배치 정책

- 메모리가 꽉 찼을 때 메모리 내에 있는 어떤 프로세스를 내보낼지 결정하는 정책
- 앞으로 사용하지 않을 프로세스를 찾아서 내보냄(교체 알고리즘)

# 메모리 주소

## 32bit CPU와 64bit CPU의 차이

- CPU의 비트: 한 번에 다룰 수 있는 데이터의 최대 크기
- CPU의 비트는 메모리 주소 공간의 크기와도 연관이 있음
- 32bit의 CPU의 경우 메모리 주소를 지정하는 레지스터인 메모리 주소 레지스터의 크기가 32bit
    - 표현할 수 있는 메모리 주소의 범위: 0~2^32-1, 총 개수: 2^32개
    - 총 크기는 2^32B, 약 4GB
    - 32bit CPU 컴퓨터는 메모리를 최대 4GB까지 사용 가능
- 64bit CPU는 레지스터의 크기, 버스의 대역폭, 한번에 처리되는 데이터의 최대 크기 등이 32bit CPU의 2배
    - 32bit CPU보다 처리 속도가 빠르고 사용할 수 있는 메모리도 큼
    - 메모리를 최대 16,777,216TB까지 사용 가능
- 컴퓨터에는 메모리가 설치되며 각 메모리 주소 공간이 존재
    - ******물리 주소 공간:****** 하드웨어 입장에서 바라본 주소 공간으로 컴퓨터마다 그 크기가 다름
    - ************************************논리 주소 공간:************************************ 사용자 입장에서 바라본 주소 공간

## 절대 주소와 상대 주소

### 메모리 영역의 구분

![단순 메모리 구조](https://yansigit.github.io/posts/%eb%ac%bc%eb%a6%ac%eb%a9%94%eb%aa%a8%eb%a6%ac-%ea%b4%80%eb%a6%ac/Untitled%202.png)

- 단순 메모리 구조: 한 번에 한 가지 일만 처리하는 일괄 처리 시스템에서 볼 수 있음
- 메모리 관리자는 이러한 메모리를 운영체제 영역과 사용자 영역으로 나누어 관리
- 사용자가 운영체제를 침범하지 못하도록 분리하여 관리
    - 사용자 프로세스는 운영체제 영역을 피하여 메모리에 적재
    - 사용자 프로세스가 운영체제의 크기에 따라 매번 적재되는 주소가 달라짐
        - 이를 개선하여 사용자 프로세스를 메모리 최상위부터 사용하는 방법이 있음

![최상위부터 사용자 영역 할당](https://velog.velcdn.com/images%2Fsunil1369%2Fpost%2F2cdb336f-9000-440d-8032-bd94736afaf4%2Fimage.png)

- 메모리를 최상위에서 운영체제 방향으로 내려오면서 사용
- 운영체제의 크기에 상관없이 사용자 영역의 시작점 결정 가능
- 메모리를 거꾸로 사용하기 위해 주소를 변경하는 일이 복잡 → 잘 쓰이지 않음

![경계 레지스터](https://velog.velcdn.com/images%2Fholim0%2Fpost%2F61d2fd60-00c0-4966-929d-25d024652ed9%2Fimage.png)

- 사용자 영역이 운영체제 영역으로 침범하는 것을 막으려면 하드웨어의 도움이 필요
    - CPU 내에 있는 **경계 레지스터**가 담당
    - 경계 레지스터: 운영체제 영역과 사용자 영역 경계 지점의 주소를 가진 레지스터
- 메모리 관리자는 사용자가 작업을 요청할 때마다 경계 레지스터의 값을 벗어나는지 검사
- 만약 경계 레지스터를 벗어나는 작업을 요청하는 프로세스가 있으면 그 프로세스 종료

### 절대 주소와 상대 주소의 개념

- 컴파일 방식을 사용하는 프로그램의 경우 컴파일 시 변수의 주소를 0번지부터 배정
- 컴파일할 당시에는 변수가 메모리의 어느 위치에 올라가는지 알 수 없음
    - 0번지부터 배정하고 실제 실행할 때 주소를 조정
    - 만약 사용자 프로세스가 메모리의 400번지에 올라간다면 프로세스 내 변수의 각 주소에 400을 더함 → 이때 400번지가 **절대 주소**
- **절대 주소:** 실제 물리 주소를 가리키며 메모리 관리자 입장에서 바라본 주소
    - 메모리 주소 레지스터가 사용하는 주소
    - 컴퓨터에 꽂힌 램 메모리의 실제 주소
- 사용자 입장에서 절대 주소를 사용하려면 매번 운영체제 영역을 확인해야함
    - 불편하고 위험
- **상대 주소:** 사용자의 영역이 시작되는 번지를 0번지로 변경하여 사용하는 주소 지정 방식
    - 사용자 프로세스 입장에서 바라본 주소
    - 절대 주소와 관계없이 항상 0번지부터 시작
    - 상대 주소가 사용할 수 없는 영역의 위치를 알 필요가 없음
- **논리 주소 공간**: 상대 주소를 사용하는 주소 공간
- **물리 주소 공간:** 절대 주소를 사용하는 주소 공간

### 상대 주소를 절대 주소로 변환하는 과정

- 메모리 접근시 상대 주소 사용하면 절대 주소로 변환해야함

![재배치 레지스터](https://yansigit.github.io/posts/%eb%ac%bc%eb%a6%ac%eb%a9%94%eb%aa%a8%eb%a6%ac-%ea%b4%80%eb%a6%ac/Untitled%204.png)

1. 사용자 프로세스가 상대 주소 40번지에 있는 데이터 요청
2. CPU는 메모리 관리자에게 40번지에 있는 내용을 가져오라고 명령
3. 메모리 관리자는 재배치 레지스터를 사용하여 상대주소를 절대주소 400번지로 변환하고, 메모리 400 번지에 저장된 데이터를 가져온다
- **재배치 레지스터:** 주소 변환의 기본이 되는 주소 값을 가진 레지스터
- 메모리 관리자는 사용자 프로세스가 상대 주소를 사용하여 메모리에 접근할 때마다 상대 주소 값에 재배치 레지스터 값을 더하여 절대 주소를 구한다

# 단일 프로그래밍 환경에서의 메모리 할당

## 메모리 오버레이

- 프로그램의 크기가 **실제 메모리(물리 메모리)보다 클 때** 전체 프로그램을 메모리에 가져오는 대신 **적당한 크기로 잘라서 가져오는 기법**
- 프로그램을 몇 개의 모듈로 나누고 필요할 때마다 모듈을 메모리에 가져와 사용
    - 필요한 중요한 모듈만 올려두고 나머지는 필요할 때마다 메모리에서 가져와서 사용
- 프로그램 전체를 메모리에 올려놓고 실행하는 것보다 속도가 느리지만 메모리가 프로그램보다 작을 때도 실행할 수 있어 유용
- **프로그램 카운터(PC)**: CPU 레지스터 중 하나로 어떤 모듈을 가져오거나 내보낼지 결정
    - 앞으로 실행할 명령어의 위치를 가리지는 레지스터
    - 해당 모듈이 메모리에 없으면 메모리 관리자에게 요청하여 메모리로 가져오게 함

### 메모리 오버레이의 의미

- 한정된 메모리에서 메모리보다 큰 프로그램이 가능
- 프로그램 전체가 아니라 일부만 메모리에 올라와도 실행 가능
    - 메모리를 여러 조각으로 나누어 여러 프로세스에 할당 가능

## 스왑

- 메모리에 모듈 B를 가져올 때 먼저 메모리에 올라온 모듈 A를 어딘가에 보관해야 함
- **스왑 영역**에 보관
    - 스왑인: 스왑 영역에서 메모리로 데이터를 가져오는 작업
    - 스왑아웃: 메모리에서 스왑 영역으로 데이터를 내보내는 작업
- 스왑 영역은 메모리 관리자가 관리
- 메모리 오버레이에서는 메모리보다 큰 프로그램을 실행할 때 프로그램을 메모리보다 작은 크기의 모듈로 나누어서 사용
    - 여기에 스왑 영역을 이용하면 스왑 영역의 크기가 메모리의 크기로 인식됨
    - 사용자는 실제 메모리의 크기와 스왑 영역의 크기를 합쳐서 전체 메모리로 인식하고 사용

# 다중 프로그래밍 환경에서의 메모리 할당

## 메모리 분할 방식

- **가변 분할 방식:** 프로세스의 크기에 따라 메모리를 나눔
- ************************************고정 분할 방식:************************************ 프로세스의 크기와 상관없이 메모리를 같은 크기로 나눔

### 메모리 분할 방식의 구현

- **가변 분할 방식**
    - 프로세스의 크기에 맞게 메모리가 분할
    - 메모리의 영역이 각각 다름
    - 한 프로세스가 연속된 공간에 배치 → **연속 메모리 할당**
    - **장점**
        - 프로세스를 한 덩어리로 처리하여 하나의 프로세스를 연속된 공간에 배치
    - **단점**
        - 메모리 관리가 복잡
        - 비어있는 공간을 하나로 합쳐야하는 메모리 통합 등의 부가적인 관리 필요
- **고정 분할 방식**
    - 프로세스의 크기에 상관없이 메모리가 같은 크기로 나뉨
    - 큰 프로세스가 메모리에 올라오면 여러 조각으로 나뉘어 배치
    - 한 프로세스가 분산되어 배치 → **비연속 메모리 할당**
    - **장점**
        - 메모리 관리가 수월
        - 부가적인 작업을 할 필요가 없음
    - **단점**
        - 쓸모없는 공간으로 인해 메모리 낭비가 발생 가능
        - 일정하게 나누어진 공간보다 작은 프로세스가 올라올 경우 메모리 낭비 발생
- 현대 운영체제에서는 기본적으로 고정 분할 방식을 사용하면서 일부분은 가변 분할 방식 혼합

## 가변 분할 방식의 메모리 관리

- 가변 분할 방식을 **세그멘테이션** 기법이라고도 함

### 프로세스 배치와 외부 단편화

- 빈 영역이 있어도 서로 떨어져 있으면 프로세스를 배정하지 못하는 문제가 발생
    - **단편화(조각화)**: 이로 인해 작은 조각이 발생하는 현상

![가변 분할 방식과 외부 단편화](https://yansigit.github.io/posts/%eb%ac%bc%eb%a6%ac%eb%a9%94%eb%aa%a8%eb%a6%ac-%ea%b4%80%eb%a6%ac/Untitled%2010.png)
- 프로세스 B와 D가 종료되면 18KB와 17KB의 빈 공간이 생김
- 이후 18KB보다 큰 프로세스가 들어오면 적당한 공간이 없어 메모리를 배정하지 못함
- 가변 분할 방식에서 발생하는 이러한 작은 빈 공간을 **외부 단편화**라고 함
    - 해결을 위해 **메모리 배치 방식**이나 **조각 모음** 사용
    - 메모리 배치 방식: 작은 조각이 발생하지 않도록 프로세스 배치
        - 선처리
    - 조각 모음: 조각이 발생했을 때 작은 조각들을 모아서 하나의 큰 덩어리로 만드는 작업
        - 후처리

### 메모리 배치 방식

- 가변 분할 방식의 외부 문제를 해결하기 위한 대표적인 메모리 방식들
- **최초 배치**
    - 단편화를 고려하지 않는 것
    - 프로세스를 메모리의 빈 공간에 배치할 때 메모리에서 적재 가능한 공간을 순서대로 찾다가 첫 번째로 발견한 공간에 프로세스 배치
    - 빈 공간을 찾아다닐 필요가 없음
- **최적 배치**
    - 메모리의 빈 공간을 모두 확인한 후 적당한 크기 가운데에 가장 작은 공간에 프로세스 배치
    - 빈 공간을 모두 확인하는 부가적인 작업이 있지만 딱 맞는 공간을 찾을 경우 단편화가 일어나지 않음
    - 딱 맞는 공간이 없다면 아주 작은 조각을 만들어내는 단점
- **최악 배치**
    - 빈 공간을 모두 확인한 후 가장 큰 공간에 프로세스 배치
    - 프로세스를 배치하고 남은 공간이 크기 때문에 남은 공간이 쓸모가 있음
    - 빈 공간의 크기가 클 때는 효과적이지만 빈 공간의 크기가 점점 줄어들면 최적 배치처럼 작은 조각을 만들어낸다

### 조각 모음

- 가변 분할 방식의 목적은 프로세스를 한 덩어리로 취급하여 메모리 관리의 효율성을 높이는 것이지만 메모리 배치 방식으로는 근본적으로 문제를 해결하지 못함
- 가변 분할 방식에서는 메모리에 올라오는 프로세스가 차례대로 배치되기 때문에 공간 사용에 큰 문제가 없음
- 그러나 작은 프로세스가 작업을 마치고 메모리에서 나가면 그 공간이 조각으로 남아 쓸모 없어질 가능성이 크다
    - 이렇게 단편화가 발생하면 이미 배치된 프로세스를 옆으로 옮겨 **빈 공간들을 하나의 큰 덩어리로** 만들어야 함 → **조각 모음**
- **조각 모음:** 서로 떨어져 있는 여러 개의 빈 공간을 합치는 작업
- 순서
    1. 조각 모음을 하기 위해 이동할 프로세스의 동작을 멈춘다
    2. 프로세스를 적당한 위치로 이동
        1. 프로세스가 원래의 위치에서 이동하기 때문에 프로세스의 상대 주소값을 바꾼다
    3. 이러한 작업을 다 마친 후 프로세스를 다시 시작
- 조각 모음시 많은 시간이 걸림
    - **가변 분할 방식**은 **외부 단편화**로 인해 조각 모음 같은 부가적인 작업이 필요해 **메모리 관리가 복잡**

## 고정 분할 방식의 메모리 관리

- 고정 분할 방식을 **페이징**이라고도 함
- 프로세스의 크기에 상관 없이 메모리를 같은 크기로 나눔
    - 관리하기 편함
- 프로세스가 메모리의 여러 조각에 나뉘어 저장되는 것이 문제

### 프로세스 배치와 내부 단편화

- 고정 분할 방식은 가변 분할 방식보다 공간을 효율적으로 관리
- 조각 모음을 할 필요가 없어 관리가 수월
    - 현대의 메모리 관리 시스템은 고정 분할 방식을 기본으로 사용

### 내부 단편화

- 고정 분할 방식을 사용하면 일정하게 나뉜 메모리의 크기보다 **작은 프로세스가 배치**될 경우 **낭비되는 공간**이 생긴다
- **내부 단편화:** 각 메모리 조각에 프로세스를 배치하고 공간이 남는 현상
- 동일하게 **분할되는 공간의 크기를 조절**하여 내부 단편화를 최소화

**비교**

| 구분 | 가변 분할 방식 | 고정 분할 방식 |
| --- | --- | --- |
| 메모리 단위 | 세그먼테이션 | 페이징 |
| 특징 | 연속 메모리 할당 | 비연속 메모리 할당 |
| 장점` | 프로세스를 한 덩어리로 관리 가능 | 메모리 관리가 편리 |
| 단점 | 빈 공간의 관리가 어려움 | 프로세스가 분할되어 처리됨 |
| 단편화 | 외부 단편화 | 내부 단편화 |

## 버디 시스템

- 외부 단편화를 완화하는 방법

### 버디 시스템의 작동 방식

1. 프로세스의 크기에 맞게 메모리를 1/2로 자르고 프로세스를 메모리에 배치
2. 나뉜 메모리의 각 구역에는 프로세스가 1개만 들어간다
3. 프로세스가 종료되면 주변의 빈 조각과 합쳐서 하나의 큰 덩어리를 만든다

### 버디 시스템의 특징

- 가변 분할 방식과 고정 분할 방식의 특징을 모두 가지고 있다
    - 메모리가 프로세스 크기대로 나뉨
    - 하나의 구역에 다른 프로세스가 들어갈 수 없고 메모리의 한 구역 내부에 조각이 생겨 내부 단편화 발생
- 비슷한 크기의 덩어리가 서로 모여 있어 통합하기가 쉬움
    - 가변 분할 방식보다 효과적으로 공간 관리 가능
    - 조각 모음을 하지 않아도 간단히 큰 덩어리를 만들 수 있다
- 효율적인 공간 관리 측면에서 보면 고정 분할 방식과 버디 시스템은 비슷한 수준
    - 그러나 공간을 1/2로 나누어가면서 메모리를 배분하는 버디 시스템보다 모든 공간을 똑같은 크기로 나누는 **고정 분할 방식이 메모리 관리 측면에서 단순**
